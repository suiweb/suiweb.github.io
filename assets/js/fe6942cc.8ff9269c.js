"use strict";(self.webpackChunksuiweb_website=self.webpackChunksuiweb_website||[]).push([[311],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(n),h=a,m=u["".concat(s,".").concat(h)]||u[h]||c[h]||o;return n?i.createElement(m,r(r({ref:t},d),{},{components:n})):i.createElement(m,r({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7589:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var i=n(7462),a=(n(7294),n(3905));const o={},r="Level 5: Defining Components the React-Way with JSX",l={unversionedId:"tutorial/5-parsing-jsx/README",id:"tutorial/5-parsing-jsx/README",title:"Level 5: Defining Components the React-Way with JSX",description:"Introduction",source:"@site/docs/tutorial/5-parsing-jsx/README.md",sourceDirName:"tutorial/5-parsing-jsx",slug:"/tutorial/5-parsing-jsx/",permalink:"/docs/tutorial/5-parsing-jsx/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"apiSidebar",previous:{title:"Level 4: Adding State to Our Components Using Hooks",permalink:"/docs/tutorial/4-hooks/"},next:{title:"Level 6: Conditionally Showing Elements",permalink:"/docs/tutorial/6-conditional-rendering/"}},s={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Goal",id:"goal",level:2},{value:"<code>index.html</code>",id:"indexhtml",level:3},{value:"<code>index.jsx</code>",id:"indexjsx",level:3},{value:"<code>package.json</code>",id:"packagejson",level:3},{value:"<code>vite.config.js</code>",id:"viteconfigjs",level:3},{value:"Creating Fibers from JSX",id:"creating-fibers-from-jsx",level:2},{value:"Syntax of JSX",id:"syntax-of-jsx",level:2},{value:"Static and Functional Fibers",id:"static-and-functional-fibers",level:3},{value:"Passing Props",id:"passing-props",level:3},{value:"Limitations of JSX in SuiWeb",id:"limitations-of-jsx-in-suiweb",level:3},{value:"Review",id:"review",level:2}],d={toc:p};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"level-5-defining-components-the-react-way-with-jsx"},"Level 5: Defining Components the React-Way with JSX"),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"Now that we've discussed the most important concepts to bring actual logic to our components, we'll go a step back in this level and look at an alternative to SJDON to define our components. This alternative is called ",(0,a.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/introducing-jsx.html"},"JSX"),", and is the recommended notation to define components when using React."),(0,a.kt)("p",null,"JSX is a syntax extension to JavaScript. As browsers are not capable to render JSX directly, we first need to transform our code to regular JavaScript, which can be done with a tool such as ",(0,a.kt)("a",{parentName:"p",href:"https://babeljs.io/"},"Babel")," or ",(0,a.kt)("a",{parentName:"p",href:"https://esbuild.github.io/"},"esbuild"),"."),(0,a.kt)("p",null,"As usual, we will first look at demo of the goal for this level, then have a first look at the basic syntax and structure of JSX and will finally we will show how code written in JSX can be rendered with SuiWeb."),(0,a.kt)("h2",{id:"goal"},"Goal"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://suiweb.github.io/demos/tutorial/05-parsing-jsx/dist/index.html"},"Demo")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/suiweb/suiweb/tree/main/demos/tutorial/05-parsing-jsx"},"Source Code"))),(0,a.kt)("p",null,"Let's take the example we have created for the previous level, which displays a ",(0,a.kt)("inlineCode",{parentName:"p"},"h1")," title, a text field and a counter button. We will recreate this example, but this time using JSX instead of SJDON."),(0,a.kt)("p",null,"Because we're using JSX, the extension of our JavaScript file will no longer be ",(0,a.kt)("inlineCode",{parentName:"p"},".js"),", but ",(0,a.kt)("inlineCode",{parentName:"p"},".jsx")," instead. Using this dedicated extension allows tools such as Babel or esbuild to know that JSX transformation should be performed on those files. First, we need to update our ",(0,a.kt)("inlineCode",{parentName:"p"},"index.html")," file to include ",(0,a.kt)("inlineCode",{parentName:"p"},"index.jsx")," (instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"index.js"),"):"),(0,a.kt)("h3",{id:"indexhtml"},(0,a.kt)("inlineCode",{parentName:"h3"},"index.html")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html"},'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>SuiWeb App</title>\n    // highlight-next-line\n    <script type="module" src="./index.jsx"><\/script>\n</head>\n<body>\n    <noscript>You need to enable JavaScript to run this app.</noscript>\n    <div id="app"></div>\n</body>\n</html>\n\n')),(0,a.kt)("p",null,"Now, let's look at our ",(0,a.kt)("inlineCode",{parentName:"p"},"index.jsx")," file:"),(0,a.kt)("h3",{id:"indexjsx"},(0,a.kt)("inlineCode",{parentName:"h3"},"index.jsx")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import { createElement } from '../../lib/js/fiber.js'\nimport { useEffect, useState } from '../../lib/js/hooks.js'\nimport { render } from '../../lib/js/render.js'\n\n// highlight-next-line\n/** @jsx createElement */\n\nconst App = () => {\n    const [text, setText] = useState('SuiWeb App')\n    const [count, setCount] = useState(0)\n\n    useEffect(\n        () => console.log('First render done'), \n        []\n    )\n\n    useEffect(\n        () => console.log(`The value of text has changed: ${text}`),\n        [text]\n    )\n\n    useEffect(\n        () => console.log('Component was re-rendered')\n    )\n\n    // highlight-start\n    return (\n        <div>\n            <h1>{text}</h1>\n            <TextField text={text} setText={setText} />\n            <Counter count={count} setCount={setCount} />\n        </div>\n    )\n    // highlight-end\n}\n\nconst TextField = ({text, setText}) => {\n    // highlight-start\n    return (\n        <div>\n            <input \n                value={text} \n                oninput={event => setText(event.target.value)} \n            />\n        </div>\n    )\n    // highlight-end\n}\n\nconst Counter = ({count, setCount}) => {\n    // highlight-start\n    return (\n        <button onclick={() => setCount(count + 1)}>\n            {`Clicked ${count} times`}\n        </button>\n    )\n    // highlight-end\n}\n\nrender(\n    // highlight-next-line\n    <App />, \n    document.getElementById('app')\n)\n")),(0,a.kt)("p",null,"All the lines which are different from ",(0,a.kt)("a",{parentName:"p",href:"/docs/tutorial/4-hooks/#indexjs"},(0,a.kt)("inlineCode",{parentName:"a"},"index.js")," of level 4")," are highlighted in the code snippet above. As you can see, the changes include a special annotation, all the return statements and small change in the ",(0,a.kt)("inlineCode",{parentName:"p"},"render")," function."),(0,a.kt)("p",null,"To then transform our JSX into regular JavaScript, we need a tool which does that transformation. We use ",(0,a.kt)("a",{parentName:"p",href:"https://vitejs.dev/"},"vite"),", which comes with ",(0,a.kt)("a",{parentName:"p",href:"https://esbuild.github.io/"},"esbuild"),", in this tutorial. But you could also use some other tools such as ",(0,a.kt)("a",{parentName:"p",href:"https://webpack.js.org/"},"webpack")," together with ",(0,a.kt)("a",{parentName:"p",href:"https://babeljs.io/"},"Babel"),"."),(0,a.kt)("p",null,"To use our project with vite, we create a ",(0,a.kt)("a",{parentName:"p",href:"https://www.npmjs.com/"},"npm")," project, which installs vite together with its dependencies inside our project. You could either run ",(0,a.kt)("inlineCode",{parentName:"p"},"npm create vite@latest")," to initialize a vite project from scratch, or just copy the ",(0,a.kt)("inlineCode",{parentName:"p"},"package.json")," file shown below."),(0,a.kt)("h3",{id:"packagejson"},(0,a.kt)("inlineCode",{parentName:"h3"},"package.json")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "name": "05-hooks",\n  "private": true,\n  "version": "0.0.0",\n  "type": "module",\n  "scripts": {\n    "dev": "vite",\n    "build": "vite build",\n    "preview": "vite preview"\n  },\n  "devDependencies": {\n    "vite": "^4.0.2"\n  }\n}\n')),(0,a.kt)("p",null,"We then install the dependencies by running ",(0,a.kt)("inlineCode",{parentName:"p"},"npm install")," inside our project's directory."),(0,a.kt)("p",null,"Then, we need to configure vite, which we do with the file ",(0,a.kt)("inlineCode",{parentName:"p"},"vite.config.js"),", that needs to be placed in the root of our project."),(0,a.kt)("h3",{id:"viteconfigjs"},(0,a.kt)("inlineCode",{parentName:"h3"},"vite.config.js")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"import { defineConfig } from 'vite'\n\nexport default defineConfig({\n    base: '',\n    build: {\n        target: 'esnext',\n        minify: false,\n        outDir: 'dist',\n        emptyOutDir: true,\n    },\n})\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note that for this simple example, it would probably not even be needed to create a config file for vite, as we could also just use the default configuration. In the config above, we have changed some default settings, such as ",(0,a.kt)("inlineCode",{parentName:"p"},"minify: false"),", so that the code which is produced by vite is a bit more readable, so that we can better see what is happening.")),(0,a.kt)("p",null,"Once that is set up, you can run ",(0,a.kt)("inlineCode",{parentName:"p"},"npm run dev")," to run vite in development mode, which should output a URL such as ",(0,a.kt)("inlineCode",{parentName:"p"},"http://localhost:5173/"),", at which you can see your built project. "),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note that it's now no longer needed to run a local web server using ",(0,a.kt)("inlineCode",{parentName:"p"},"npx serve"),", as running vite in development mode takes care of this.")),(0,a.kt)("p",null,"To understand how JSX will be rendered using SuiWeb, let's first have a look at how Fibers are created from JSX code."),(0,a.kt)("h2",{id:"creating-fibers-from-jsx"},"Creating Fibers from JSX"),(0,a.kt)("p",null,"As mentioned already, our code contains the annotation ",(0,a.kt)("inlineCode",{parentName:"p"},"/** @jsx createElement */"),", which tells esbuild (that is run as part of vite) to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement")," function of SuiWeb to transform from JSX to JS."),(0,a.kt)("p",null,"This basically replaces what ",(0,a.kt)("inlineCode",{parentName:"p"},"parseSjdon")," did, when we used it to convert our SJDON arrays into calls of ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement"),"."),(0,a.kt)("p",null,"The difference is that now, the transformation to ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement")," calls happens as a ",(0,a.kt)("strong",{parentName:"p"},"build step")," of our app (which is performed by vite, previously to actually running our app), and not during runtime (which is the case for ",(0,a.kt)("inlineCode",{parentName:"p"},"parseSjdon"),")."),(0,a.kt)("p",null,"If you run ",(0,a.kt)("inlineCode",{parentName:"p"},"npm run build"),", you can see the code that is created by vite inside the directory ",(0,a.kt)("inlineCode",{parentName:"p"},"dist/assets")," in a file that is called something like ",(0,a.kt)("inlineCode",{parentName:"p"},"index.0a9bd48a.js"),". You can also see that the import statement of the ",(0,a.kt)("inlineCode",{parentName:"p"},"index.html")," file, which is placed in ",(0,a.kt)("inlineCode",{parentName:"p"},"dist"),", has been updated to reflect the correct path of our ",(0,a.kt)("em",{parentName:"p"},"bundled")," JS file. This code contains basically all functions that are needed from SuiWeb, as well as the components we defined in our ",(0,a.kt)("inlineCode",{parentName:"p"},"index.jsx")," file, in plain JavaScript code which uses ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement")," calls."),(0,a.kt)("p",null,"For example, our ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," function looks now something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'const Counter = ({ count, setCount }) => {\n  return /* @__PURE__ */ createElement("button", { onclick: () => setCount(count + 1) }, `Clicked ${count} times`);\n};\n')),(0,a.kt)("p",null,"With that, you should now have an understanding on ",(0,a.kt)("em",{parentName:"p"},"how")," vite transforms our code from JSX to plain JavaScript. Next, we are going to have a look at the syntax of JSX."),(0,a.kt)("h2",{id:"syntax-of-jsx"},"Syntax of JSX"),(0,a.kt)("p",null,'If you have some basic knowledge of HTML (which you most probably have when working through this tutorial), you might have realized immediately that JSX looks a lot like HTML (or XML). The extension JSX actually also stands for "JavaScript XML", as JSX enriches the syntax of JavaScript to tags that are inspired by XML.'),(0,a.kt)("h3",{id:"static-and-functional-fibers"},"Static and Functional Fibers"),(0,a.kt)("p",null,"Basically, JSX has the following conventions for tag names:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Whenever the tag name of an element starts with a lowercase letter, it will be treated as a string."),(0,a.kt)("li",{parentName:"ul"},"If the tag name of an element starts with a capital letter, it will be treated as a function that needs to be defined in the same file (or imported).")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note: A tag name is what is written in between the ",(0,a.kt)("inlineCode",{parentName:"p"},"<>"),", e.g., the tag name of ",(0,a.kt)("inlineCode",{parentName:"p"},"<div>"),' is "div".')),(0,a.kt)("p",null,"We can see this in the example above: Our component ",(0,a.kt)("inlineCode",{parentName:"p"},"App")," returns a structure which contains both lowercase (e.g., ",(0,a.kt)("inlineCode",{parentName:"p"},"<div>")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"h1"),") and capitalized (e.g., ",(0,a.kt)("inlineCode",{parentName:"p"},"<TextField>")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"<Counter>"),") tags. For lowercase tags, regular HTML elements will be created. For capitalized tags, the corresponding function will be executed when the component is rendered."),(0,a.kt)("p",null,"This is basically the same behavior which we had in SJDON, except that we did an explicit differentiation between strings and functions, as we only use the regular JavaScript syntax for SJDON."),(0,a.kt)("p",null,"With the explanation of this differentiation between lowercase and capitalized tag names, it should be quite obvious that lowercase letter tags will call ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement")," with a string as the first argument, which produces a ",(0,a.kt)("inlineCode",{parentName:"p"},"StaticFiber"),", while capitalized tag names call ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement")," with a function as the first parameter, what produces a ",(0,a.kt)("inlineCode",{parentName:"p"},"FunctionalFiber"),"."),(0,a.kt)("h3",{id:"passing-props"},"Passing Props"),(0,a.kt)("p",null,"Another thing that changes with JSX as compared to SJDON is how we pass props for a component (the object which we pass as the parameter of a component function)."),(0,a.kt)("p",null,"While in SJDON, we could just pass one or multiple objects at any position (except the first), we do this a little different in JSX."),(0,a.kt)("p",null,"Like attributes which you might know from HTML (such as the ",(0,a.kt)("inlineCode",{parentName:"p"},"value")," attribute on an ",(0,a.kt)("inlineCode",{parentName:"p"},"input"),"), we use the same (or similar) syntax in JSX. We define the name of the property and then the value, which could either be a string, or some JavaScript code. Note that if it's just a string, you would have to use quotation marks (as in regular HTML), and if you want to pass some JavaScript code, such as a variable, you would wrap your JS code with curly braces ",(0,a.kt)("inlineCode",{parentName:"p"},"{ ... }"),"."),(0,a.kt)("p",null,"In the transformation, all attributes of a JSX element will then be passed in an object as the second parameter to our ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement"),' function (which you can also see in the example of the "compiled" ',(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," function)."),(0,a.kt)("h3",{id:"limitations-of-jsx-in-suiweb"},"Limitations of JSX in SuiWeb"),(0,a.kt)("p",null,"Note that SuiWeb currently does not include support for ",(0,a.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/fragments.html"},"Fragments"),". Due to this, the syntax to create a fragment using the syntax ",(0,a.kt)("inlineCode",{parentName:"p"},"<> ... </>")," is not supported when using JSX with SuiWeb. It would, however, be possible to add support and register the function to create a fragment using the annotation ",(0,a.kt)("inlineCode",{parentName:"p"},"/** @jsxFrag createFragment */"),", similar to the annotation we use to register our ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement")," function. For now, we decided to not include it in order to keep down the complexity of SuiWeb."),(0,a.kt)("h2",{id:"review"},"Review"),(0,a.kt)("p",null,'With that, you should now understand how you can use JSX instead of SJDON to define your components. Using JSX might feel a bit more natural, as its syntax feels similar to that of HTML. The "downside" is, however, that JSX code needs to be transformed with a tool such as esbuild or Babel, which might not be possible in some cases. For most applications we develop nowadays, however, we use tools such as vite or webpack anyway, to bundle many individual files and their dependencies into a single file (or multiple chunks). So that additional build step might often not be a problem.'),(0,a.kt)("p",null,"In the ",(0,a.kt)("a",{parentName:"p",href:"/docs/tutorial/6-conditional-rendering/"},"next level"),", we will go back to actual SuiWeb logic, and see how we can conditionally render components or parts of components, depending on some conditions."))}u.isMDXComponent=!0}}]);