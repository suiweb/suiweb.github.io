"use strict";(self.webpackChunksuiweb_website=self.webpackChunksuiweb_website||[]).push([[658],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=p(n),u=a,m=h["".concat(s,".").concat(u)]||h[u]||c[u]||o;return n?i.createElement(m,r(r({ref:t},d),{},{components:n})):i.createElement(m,r({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:a,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},483:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var i=n(7462),a=(n(7294),n(3905));const o={},r="Level 4: Adding State to Our Components Using Hooks",l={unversionedId:"tutorial/4-hooks/README",id:"tutorial/4-hooks/README",title:"Level 4: Adding State to Our Components Using Hooks",description:"Introduction",source:"@site/docs/tutorial/4-hooks/README.md",sourceDirName:"tutorial/4-hooks",slug:"/tutorial/4-hooks/",permalink:"/docs/tutorial/4-hooks/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"apiSidebar",previous:{title:"Level 3: Splitting Code Into Components",permalink:"/docs/tutorial/3-components/"},next:{title:"Level 5: Defining Components the React-Way with JSX",permalink:"/docs/tutorial/5-parsing-jsx/"}},s={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Goal",id:"goal",level:2},{value:"<code>index.js</code>",id:"indexjs",level:3},{value:"Using Hooks",id:"using-hooks",level:2},{value:"The Hooks Module",id:"the-hooks-module",level:2},{value:"Preparing the Use of Hooks",id:"preparing-the-use-of-hooks",level:3},{value:"The <code>useState</code> Hook",id:"the-usestate-hook",level:2},{value:"Re-Rendering Fibers",id:"re-rendering-fibers",level:3},{value:"Revisiting the <code>renderFiber</code> Function",id:"revisiting-the-renderfiber-function",level:3},{value:"The <code>updateFiberInDom</code> function",id:"the-updatefiberindom-function",level:3},{value:"Revisiting the <code>expandChildFibers</code> Function",id:"revisiting-the-expandchildfibers-function",level:3},{value:"The <code>useEffect</code> Hook",id:"the-useeffect-hook",level:2},{value:"Review",id:"review",level:2}],d={toc:p};function h(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"level-4-adding-state-to-our-components-using-hooks"},"Level 4: Adding State to Our Components Using Hooks"),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"Until now, we are able to split up our code into multiple components, which can either be static or functional elements. But as our components will just be rendered once so far, it's not possible to really interact with those components."),(0,a.kt)("p",null,"In this level, we are going to explore how we can ",(0,a.kt)("em",{parentName:"p"},"store")," data inside a component and re-render the component automatically once that data changes. This will allow us to interact with the component and return results which depend on previous executions of it, meaning that the functions of our components become ",(0,a.kt)("em",{parentName:"p"},"stateful"),"."),(0,a.kt)("p",null,"To do so, we are going to look at the concept of ",(0,a.kt)("strong",{parentName:"p"},"Hooks")," in this level. SuiWeb comes with two hooks, namely ",(0,a.kt)("a",{parentName:"p",href:"/docs/api/internal/modules/hooks#usestate"},(0,a.kt)("inlineCode",{parentName:"a"},"useState"))," and ",(0,a.kt)("a",{parentName:"p",href:"/docs/api/internal/modules/hooks#useeffect"},(0,a.kt)("inlineCode",{parentName:"a"},"useEffect")),", which are both also available in React with almost the same syntax. Note that React includes various additional hooks, which are not implemented in SuiWeb to keep things simple. Having seen and understood the two hooks implemented in SuiWeb, however, should give you good understanding of how the concept generally works, which is the goal of SuiWeb after all."),(0,a.kt)("p",null,"With that, let's look at demo we have for this level on what we want to achieve."),(0,a.kt)("h2",{id:"goal"},"Goal"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://suiweb.github.io/demos/tutorial/04-hooks/index.html"},"Demo")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/suiweb/suiweb/tree/main/demos/tutorial/04-hooks"},"Source Code"))),(0,a.kt)("p",null,"We create two components for the demo of this level. When we render it, we can see a ",(0,a.kt)("inlineCode",{parentName:"p"},"h1")," title, a text field and a button. The title displays what is currently written to the text field, and updates automatically as soon as the text in the text field changes. The button shows how many times it has been clicked, and updates every time it is clicked."),(0,a.kt)("p",null,"Here is the source code of our ",(0,a.kt)("inlineCode",{parentName:"p"},"index.js")," for the current level. The contents of ",(0,a.kt)("inlineCode",{parentName:"p"},"index.html")," remain unchanged."),(0,a.kt)("h3",{id:"indexjs"},(0,a.kt)("inlineCode",{parentName:"h3"},"index.js")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"import { createElement } from '../../lib/js/fiber.js'\nimport { useEffect, useState } from '../../lib/js/hooks.js'\nimport { render } from '../../lib/js/render.js'\nimport { parseSjdon } from '../../lib/js/sjdon.js'\n\n\nconst App = () => {\n    const [text, setText] = useState('SuiWeb App')\n    const [count, setCount] = useState(0)\n\n    useEffect(\n        () => console.log('First render done'), \n        []\n    )\n\n    useEffect(\n        () => console.log(`The value of text has changed: ${text}`),\n        [text]\n    )\n\n    useEffect(\n        () => console.log('Component was re-rendered')\n    )\n\n    return [\n        'div',\n        ['h1', text],\n        [TextField, {text, setText}],\n        [Counter, {count, setCount}]\n    ]\n}\n\nconst TextField = ({text, setText}) => {\n    return [\n        'div',\n        [\n            'input',\n            {\n                value: text,\n                oninput: (event) => setText(event.target.value),\n            },\n        ],\n    ]\n}\n\nconst Counter = ({count, setCount}) => {\n    return [\n        'button', \n        { onclick: () => setCount(count + 1) }, \n        `Clicked ${count} times`\n    ]\n}\n\nrender(\n    parseSjdon([App], createElement), \n    document.getElementById('app')\n)\n")),(0,a.kt)("p",null,"Because the title updates automatically as we change the value of the text field, we need some logic that re-renders the component ",(0,a.kt)("inlineCode",{parentName:"p"},"App"),", if the ",(0,a.kt)("em",{parentName:"p"},"internal data")," of the component changes, as we have mentioned in the introduction. "),(0,a.kt)("p",null,"To understand how this is working, we are first going to have a look at how we ",(0,a.kt)("em",{parentName:"p"},"use")," the functions provided by SuiWeb to achieve this functionality, and will then dive into how it works under the hood."),(0,a.kt)("h2",{id:"using-hooks"},"Using Hooks"),(0,a.kt)("p",null,"Inside the function (or ",(0,a.kt)("em",{parentName:"p"},"component"),") ",(0,a.kt)("inlineCode",{parentName:"p"},"App"),", we call the ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," function (or ",(0,a.kt)("em",{parentName:"p"},"hook"),") with an initial value of ",(0,a.kt)("inlineCode",{parentName:"p"},"'SuiWeb App'"),". This call returns an array, which we destructure to two constants ",(0,a.kt)("inlineCode",{parentName:"p"},"text")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"setText"),". Initially, ",(0,a.kt)("inlineCode",{parentName:"p"},"text")," has the value ",(0,a.kt)("inlineCode",{parentName:"p"},"'SuiWeb App'"),", as this is what we passed as the ",(0,a.kt)("inlineCode",{parentName:"p"},"initialValue")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"useState"),". ",(0,a.kt)("inlineCode",{parentName:"p"},"setText")," is a function which we can use to update the value assigned to ",(0,a.kt)("inlineCode",{parentName:"p"},"text")," and trigger a re-rendering of the component."),(0,a.kt)("p",null,"Similarly, we call ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," once more in the following line, passing ",(0,a.kt)("inlineCode",{parentName:"p"},"0")," as the initial value and storing destructured result in two constants ",(0,a.kt)("inlineCode",{parentName:"p"},"count")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"setCount"),"."),(0,a.kt)("p",null,"Going further in the implementation of our ",(0,a.kt)("inlineCode",{parentName:"p"},"App")," component, we can see three calls of the hook ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect"),', which all print some text to the console. If we look at the console, we can see that the text "First render done" is printed only once, after the component ',(0,a.kt)("inlineCode",{parentName:"p"},"App")," was rendered for the first time. We tell the effect to do so, by defining an empty array (",(0,a.kt)("inlineCode",{parentName:"p"},"[]"),") as the second argument when calling ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect"),". If you look at the console while altering the text of the text field, you will see that the ",(0,a.kt)("em",{parentName:"p"},"actions")," of the second and the third effect are executed every time the text changes. For the second call of ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect"),", we set its dependencies (defined in the second argument) to ",(0,a.kt)("inlineCode",{parentName:"p"},"[text]"),". This means that the ",(0,a.kt)("em",{parentName:"p"},"action")," of the effect will execute every time the component re-renders, if the value of ",(0,a.kt)("inlineCode",{parentName:"p"},"text")," has changed since it last rendered. At our third call to ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect"),", we did not set the second parameter, meaning we did not set any dependencies. Because of this, the ",(0,a.kt)("em",{parentName:"p"},"action")," of our third effect will be executed on ",(0,a.kt)("em",{parentName:"p"},"every")," re-rendering, no matter ",(0,a.kt)("em",{parentName:"p"},"which"),' value was updated. We can verify this by looking at the console while clicking the counter button: The only text that will be printed is "Component was re-rendered".'),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note that the behavior of ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," is different when ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"not")," passing anything")," as its ",(0,a.kt)("em",{parentName:"p"},"dependencies"),", vs. ",(0,a.kt)("strong",{parentName:"p"},"passing an empty array (",(0,a.kt)("inlineCode",{parentName:"strong"},"[]"),")"),": Passing an ",(0,a.kt)("strong",{parentName:"p"},"empty array")," will execute the action of the effect ",(0,a.kt)("strong",{parentName:"p"},"exactly once"),", on the initial rendering, while passing ",(0,a.kt)("strong",{parentName:"p"},"nothing")," (or ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined"),"), will execute the action on ",(0,a.kt)("strong",{parentName:"p"},"every execution")," of the component. If you think it's a strange decision to differentiate on the behavior like that, well, this is how the ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," hook of React works, and we wanted ours to work the same way as it does in React.")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"App")," component returns an SJDON structure, with a ",(0,a.kt)("inlineCode",{parentName:"p"},"div")," at the top level and two child elements: A ",(0,a.kt)("inlineCode",{parentName:"p"},"h1")," with the current value of ",(0,a.kt)("inlineCode",{parentName:"p"},"text")," as its content, the ",(0,a.kt)("inlineCode",{parentName:"p"},"TextField")," component and the ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," component. We pass an object consisting of our ",(0,a.kt)("inlineCode",{parentName:"p"},"text")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"setText")," as the ",(0,a.kt)("inlineCode",{parentName:"p"},"props")," to our ",(0,a.kt)("inlineCode",{parentName:"p"},"TextField")," component and one consisting of ",(0,a.kt)("inlineCode",{parentName:"p"},"count")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"setCount")," to our ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," component."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"TextField")," component returns an ",(0,a.kt)("inlineCode",{parentName:"p"},"input"),", that is wrapped inside a ",(0,a.kt)("inlineCode",{parentName:"p"},"div"),". If the value of the ",(0,a.kt)("inlineCode",{parentName:"p"},"input")," changes (",(0,a.kt)("inlineCode",{parentName:"p"},"oninput"),"), the ",(0,a.kt)("inlineCode",{parentName:"p"},"setText")," function, which was passed to the component, will be called with the current value of the input."),(0,a.kt)("p",null,"Things are similar for our ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," component. We return a button with a text that displays the current value of ",(0,a.kt)("inlineCode",{parentName:"p"},"count"),", that will be passed in the props of the function. When the button is clicked (",(0,a.kt)("inlineCode",{parentName:"p"},"onclick"),"), we call the ",(0,a.kt)("inlineCode",{parentName:"p"},"setCount")," function, that was passed via props as well, with the value ",(0,a.kt)("inlineCode",{parentName:"p"},"count + 1"),"."),(0,a.kt)("p",null,"With that, the components will re-render every time the ",(0,a.kt)("em",{parentName:"p"},"state")," of the component changes, which happens by calling the ",(0,a.kt)("inlineCode",{parentName:"p"},"setText")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"setCount")," functions. Re-rendering a component basically means executing the function which defines the component, and then updating the existing HTML element which is present in the DOM, to reflect the changes that happened. If we update the value of ",(0,a.kt)("inlineCode",{parentName:"p"},"text")," using ",(0,a.kt)("inlineCode",{parentName:"p"},"setText"),", for example, this will run the ",(0,a.kt)("inlineCode",{parentName:"p"},"App")," function, as this ",(0,a.kt)("em",{parentName:"p"},"state")," is defined in the ",(0,a.kt)("inlineCode",{parentName:"p"},"App")," component. The difference from the first execution of ",(0,a.kt)("inlineCode",{parentName:"p"},"App")," is that now, ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," does not return what is passed as the ",(0,a.kt)("inlineCode",{parentName:"p"},"initialValue"),", but what was set previously using the ",(0,a.kt)("inlineCode",{parentName:"p"},"setText")," function. This means that the ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," function somehow recognizes that it already has a value for that exact ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," call, and returns that, instead of the initial value. This is what makes hooks somehow magic. Now, let's have a look at their implementation to demystify them a bit."),(0,a.kt)("h2",{id:"the-hooks-module"},"The Hooks Module"),(0,a.kt)("p",null,"To understand how hooks work, we need to revisit the ",(0,a.kt)("inlineCode",{parentName:"p"},"unwrapFunctionalFiber")," function. So far, we have left away everything inside that function that was related to hooks. Now, we will have a look at the full implementation."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function unwrapFunctionalFiber(fiber: FunctionalFiber, container: HTMLElement, previousVersion?: Fiber) {\n    // highlight-start\n    // Copy memorizedStates from previousStates, or assign an empty array in case there is none\n    fiber.memorizedStates = (previousVersion as FunctionalFiber)?.memorizedStates ?? []\n\n    // Make fiber ready for hook calls.\n    prepareToUseHooks(fiber.memorizedStates, () => rerenderFunctionalFiber(fiber, container))\n    // highlight-end\n\n    // Unwrap fibers until the fiberFunction returns a StaticFiber.\n    let unwrappedFiber = fiber.fiberFunction(fiber.functionProps)\n    while (isFunctionalFiber(unwrappedFiber))\n        unwrappedFiber = unwrappedFiber.fiberFunction(unwrappedFiber.functionProps)\n\n    // Merge all properties of the unwrappedFiber into the functional fiber.\n    Object.assign(fiber, unwrappedFiber)\n}\n")),(0,a.kt)("p",null,"In the first line of the function, we can see that the ",(0,a.kt)("inlineCode",{parentName:"p"},"memorizedStates")," property of the ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber")," which is unwrapped, is retrieved from the ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion"),"'s ",(0,a.kt)("inlineCode",{parentName:"p"},"memorizedStates")," property, in case that exists. Otherwise, it is initialized as an empty array."),(0,a.kt)("p",null,"The reason why we try to retrieve the value from the previous version is exactly because of what we have discussed before: Re-rendering means re-executing the function that defines a component. If that happens, however, the Fiber will no longer have its ",(0,a.kt)("inlineCode",{parentName:"p"},"memorizedStates")," array, as initializing this array is not part of the Fiber's ",(0,a.kt)("inlineCode",{parentName:"p"},"fiberFunction"),", but happens inside ",(0,a.kt)("inlineCode",{parentName:"p"},"unwrapFunctionalFiber"),", as you have seen before. If we wouldn't copy over the value from the Fiber's previous version, we would initialize an empty array at each execution of the component, meaning that we would lose everything that was previously written to the array. This is why for every render, except of the first one, we will always also pass the previous version of a Functional Fiber to ",(0,a.kt)("inlineCode",{parentName:"p"},"unwrapFunctionalFiber"),"."),(0,a.kt)("h3",{id:"preparing-the-use-of-hooks"},"Preparing the Use of Hooks"),(0,a.kt)("p",null,"In the following line of ",(0,a.kt)("inlineCode",{parentName:"p"},"unwrapFunctionalFiber"),", we can see that the function ",(0,a.kt)("inlineCode",{parentName:"p"},"prepareToUseHooks")," is called. We pass it the ",(0,a.kt)("inlineCode",{parentName:"p"},"memorizedStates")," array of our ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber")," and an anonymous (arrow) function, in which will call ",(0,a.kt)("inlineCode",{parentName:"p"},"rerenderFunctionalFiber(fiber, container)")," once it's executed. We will take a look at ",(0,a.kt)("inlineCode",{parentName:"p"},"renderFunctionalFiber")," later in this level, for now just know, that we will use it to trigger a re-rendering of the component, once its state has changed."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export function prepareToUseHooks(memorizedStates: unknown[], rerenderFunction: () => void) {\n    states = memorizedStates\n    rerender = rerenderFunction\n    stateIndex = 0\n}\n")),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"prepareToUseHooks"),", we assign the parameters ",(0,a.kt)("inlineCode",{parentName:"p"},"memorizedStates")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"rerenderFunction")," to the variables ",(0,a.kt)("inlineCode",{parentName:"p"},"states")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"rerender"),", which are defined globally in the ",(0,a.kt)("em",{parentName:"p"},"hooks")," module. Additionally, we reset the global variable ",(0,a.kt)("inlineCode",{parentName:"p"},"stateIndex")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),". It might actually seem quite strange that we set those values globally on the ",(0,a.kt)("em",{parentName:"p"},"hooks")," module, as we have nothing like an instance of this module. So calling ",(0,a.kt)("inlineCode",{parentName:"p"},"prepareToUseHooks")," again will overwrite the values we've just set. But this is actually not really a problem, as you will see when we look into the implementations of ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect"),", because those global values are just used temporarily."),(0,a.kt)("p",null,"With those two additions to ",(0,a.kt)("inlineCode",{parentName:"p"},"unwrapFunctionalFiber"),", we have now covered the full implementation of this function, as the rest of the lines have already been discussed throughout the previous levels."),(0,a.kt)("h2",{id:"the-usestate-hook"},"The ",(0,a.kt)("inlineCode",{parentName:"h2"},"useState")," Hook"),(0,a.kt)("p",null,"Now that we've seen how the use of hooks is being prepared, let's have a look at the implementation of the ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export function useState<T>(initialValue: T): [T, (newValue: T) => void] {\n    // By assining these variables inside this function, their references are captured.\n    // This means that when setState is called later, e.g., the capturedStates array\n    // still has the same reference as it had at the time this function (useState) was called.\n    const capturedStates = states\n    const capturedRerender = rerender\n    const capturedStateIndex = stateIndex\n\n    // The current value of the state\n    const state = (capturedStates[capturedStateIndex] ?? initialValue) as T\n\n    // This function updates the values of the states and triggers a re-render of the component.\n    const setState = (newValue: T) => {\n        capturedStates[capturedStateIndex] = newValue\n        capturedRerender()\n    }\n\n    // The state index is incremented, so the correct element from the array is taken as the state value.\n    stateIndex++\n\n    return [state, setState]\n}\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note the ",(0,a.kt)("inlineCode",{parentName:"p"},"<T>")," after ",(0,a.kt)("inlineCode",{parentName:"p"},"useState"),". This means that the function uses a generic type, that we call ",(0,a.kt)("inlineCode",{parentName:"p"},"T"),". We define that both the parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"initialValue")," and the parameter of the closure that is returned are of the same type, which we declare by assigning ",(0,a.kt)("inlineCode",{parentName:"p"},"T")," to both of them. If we later call ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," with a number, ",(0,a.kt)("inlineCode",{parentName:"p"},"T")," will correspond to the type ",(0,a.kt)("inlineCode",{parentName:"p"},"number"),", if we call ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," with a string, ",(0,a.kt)("inlineCode",{parentName:"p"},"T")," will correspond to ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),", etc.")),(0,a.kt)("p",null,"In the first three lines, our global variables ",(0,a.kt)("inlineCode",{parentName:"p"},"states"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"rerender")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"stateIndex"),", which we set before in ",(0,a.kt)("inlineCode",{parentName:"p"},"prepareToUseHooks"),", are now assigned to the local variables ",(0,a.kt)("inlineCode",{parentName:"p"},"capturedStates"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"capturedRerender")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"capturedStateIndex"),". Remember how we previously said that it's not really a problem that those variables are set globally? This is the explanation for it. When a component is rendered, we first call ",(0,a.kt)("inlineCode",{parentName:"p"},"prepareToUseHooks"),", followed by the ",(0,a.kt)("inlineCode",{parentName:"p"},"fiberFunction"),", which is stored on the component we are going to render. The calls to ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," are defined in the ",(0,a.kt)("inlineCode",{parentName:"p"},"fiberFunction"),". That means that all ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," calls of a component are executed before ",(0,a.kt)("inlineCode",{parentName:"p"},"prepareToUseHooks")," is called for another component. Thus, the global variables are needed only for a really short time. They allow us to access what was passed to ",(0,a.kt)("inlineCode",{parentName:"p"},"prepareToUseHooks")," inside ",(0,a.kt)("inlineCode",{parentName:"p"},"useState"),", without having to pass those values directly to the ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," call."),(0,a.kt)("p",null,"Next, we assign the constant ",(0,a.kt)("inlineCode",{parentName:"p"},"state"),". For that, we check whether a value inside our ",(0,a.kt)("inlineCode",{parentName:"p"},"capturedStates")," array exists at the index of ",(0,a.kt)("inlineCode",{parentName:"p"},"captuedStateIndex"),". Remember that ",(0,a.kt)("inlineCode",{parentName:"p"},"capturedStates")," is actually just a reference to the ",(0,a.kt)("inlineCode",{parentName:"p"},"memorizedStates")," array, which belongs to the Fiber for which we define the state. If no value at ",(0,a.kt)("inlineCode",{parentName:"p"},"capturedStateIndex")," exists in the ",(0,a.kt)("inlineCode",{parentName:"p"},"capturedStates")," array, we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"initialValue"),", which was passed to the ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," function."),(0,a.kt)("p",null,"After having retrieved the current state, we define our ",(0,a.kt)("inlineCode",{parentName:"p"},"setState")," function (also called a closure). It takes one parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"newValue"),". Inside the function body of ",(0,a.kt)("inlineCode",{parentName:"p"},"setState")," we ",(0,a.kt)("em",{parentName:"p"},"capture")," the variables ",(0,a.kt)("inlineCode",{parentName:"p"},"capturedStates"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"capturedStateIndex")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"capturedRenderer"),". This means that if we will later execute the ",(0,a.kt)("inlineCode",{parentName:"p"},"setState")," function, the values will still be available inside ",(0,a.kt)("inlineCode",{parentName:"p"},"setState"),", even though this will be ",(0,a.kt)("em",{parentName:"p"},"after")," the ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," function has been executed, and thus those variables would normally no longer exist. If you want to read more on closures and capturing variables inside closures, you might find ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures"},"this page")," interesting."),(0,a.kt)("p",null,"Following the definition of our ",(0,a.kt)("inlineCode",{parentName:"p"},"setState")," closure, we increment ",(0,a.kt)("inlineCode",{parentName:"p"},"stateIndex"),". With that, it will be possible to later read out the current ",(0,a.kt)("em",{parentName:"p"},"state")," value from the ",(0,a.kt)("inlineCode",{parentName:"p"},"capturedStates")," array. This is possible because all ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," calls defined in a component will always be called in the same order, thus when a component is re-rendered, ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," will be called as many times at it has been called when it was rendered the previous time. And remember that inside ",(0,a.kt)("inlineCode",{parentName:"p"},"prepareToUseHooks"),", we then reset ",(0,a.kt)("inlineCode",{parentName:"p"},"stateIndex")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),", to make sure that counting up is starting again from ",(0,a.kt)("inlineCode",{parentName:"p"},"0")," for the next component that will be rendered."),(0,a.kt)("p",null,"Ultimately, we return ",(0,a.kt)("inlineCode",{parentName:"p"},"state")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"setState")," in an array. Usually, we use a ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"},"destructuring assignment")," to set the returned values of ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," to some constants, like we did with ",(0,a.kt)("inlineCode",{parentName:"p"},"text")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"setText")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"count")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"setCount")," in the example we've looked at in the beginning of this level."),(0,a.kt)("p",null,"If we later call the closure defined in ",(0,a.kt)("inlineCode",{parentName:"p"},"setState")," (which we called ",(0,a.kt)("inlineCode",{parentName:"p"},"setText")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"setCount")," in the example), what is passed as ",(0,a.kt)("inlineCode",{parentName:"p"},"newValue")," will be inserted into ",(0,a.kt)("inlineCode",{parentName:"p"},"capturedStates")," (which still points at the same ",(0,a.kt)("inlineCode",{parentName:"p"},"memorizedStates")," array inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"FunctionalFiber"),") at ",(0,a.kt)("inlineCode",{parentName:"p"},"capturedStateIndex"),". As the state has changed, we should now trigger a re-rendering of the component. For that, we call the ",(0,a.kt)("inlineCode",{parentName:"p"},"capturedRerender")," function."),(0,a.kt)("p",null,"Remember that we initially set what's now stored in ",(0,a.kt)("inlineCode",{parentName:"p"},"capturedRerender")," inside ",(0,a.kt)("inlineCode",{parentName:"p"},"unwrapFunctionalFiber"),", when we called ",(0,a.kt)("inlineCode",{parentName:"p"},"prepareToUseHooks"),". If we go back there, we can see that what is going to be executed is ",(0,a.kt)("inlineCode",{parentName:"p"},"rerenderFunctionalFiber(fiber, container)"),"."),(0,a.kt)("h3",{id:"re-rendering-fibers"},"Re-Rendering Fibers"),(0,a.kt)("p",null,"So it would be good to also look at the implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"rerenderFunctionalFiber")," at this point, to understand what actually happens when ",(0,a.kt)("inlineCode",{parentName:"p"},"capturedRerender")," is executed."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export function rerenderFunctionalFiber(fiber: FunctionalFiber, container: HTMLElement) {\n    // The previous version is just a copy of the functionalFiber, which should be re-rendered.\n    // This copy contains all expanded static fibers with their children -\n    // the whole fiber tree below this functional fiber.\n    // While rendering, the functional fiber will recompute all its children with the fiberFunction.\n    // By providing this copy, the previous versions children are still retained and\n    // can be compared to the new children generated by the fiberFunction.\n    const previousVersion = { ...fiber }\n    renderFiber(fiber, container, previousVersion)\n}\n")),(0,a.kt)("p",null,"As you can see, it's actually just two lines of code, but several lines of comments explaining the first line, in which the ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," is determined. If you read through them, it should be clear what is happening. Note that we use the ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax"},"spread syntax"),", to make sure ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," is a ",(0,a.kt)("em",{parentName:"p"},"new")," object, and not just a reference to ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber"),". This would be pointless, as ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber")," would contain a reference to the same object, which would not help to solve the problem that ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," solves."),(0,a.kt)("p",null,"You might remember that ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," was a parameter for a lot of functions (",(0,a.kt)("inlineCode",{parentName:"p"},"renderFiber"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"expandChildFibers"),"), we looked at, but we never really used it so far. This will change now. As we have a copy of how the fiber and its children looked like, we can start a re-rendering and compare the newly created fibers (which will probably look different as the state has changed) with the old fibers. We will then only apply the changes to the DOM, instead of removing all contents and adding everything again from scratch."),(0,a.kt)("p",null,"Now, we will go through the most important functions in the rendering process and see what has to be changed, to work with this new parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion"),". We start with the function ",(0,a.kt)("inlineCode",{parentName:"p"},"renderFiber")," which is called on the last line of ",(0,a.kt)("inlineCode",{parentName:"p"},"rerenderFunctionalFiber"),"."),(0,a.kt)("h3",{id:"revisiting-the-renderfiber-function"},"Revisiting the ",(0,a.kt)("inlineCode",{parentName:"h3"},"renderFiber")," Function"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function renderFiber(fiber: Fiber, container: HTMLElement, previousVersion?: Fiber, nextSibling?: Fiber) {\n    // If the component is a functional fiber, execute its fiberFunction\n    // to get the unwrapped StaticFiber properties merged into the same object.\n    if (isFunctionalFiber(fiber)) unwrapFunctionalFiber(fiber, container, previousVersion)\n\n    // After unwrapping, the fiber must contain all properties of a static fiber.\n    if (!isStaticFiber(fiber)) throw new Error('Fiber did not contain all StaticFiber properties after unwrapping.')\n\n    // highlight-start\n    // Determines if the new fiber still has the same type as the old fiber.\n    const areSameType = fiber && previousVersion && fiber.type === previousVersion.type\n\n    // Got a fiber with the same type in the tree, so just update the contents of the DOM node.\n    if (areSameType) updateFiberInDom(fiber, container, previousVersion, nextSibling)\n    // The types did not match, create new DOM node and remove previous DOM node.\n    else replaceFiberInDom(fiber, container, previousVersion, nextSibling)\n    // highlight-end\n\n    expandChildFibers(fiber, previousVersion)\n}\n")),(0,a.kt)("p",null,"You're looking at the almost complete implementation of the function ",(0,a.kt)("inlineCode",{parentName:"p"},"renderFiber"),". In this version, we compare the ",(0,a.kt)("inlineCode",{parentName:"p"},"type"),"s of the ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," and the current ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber"),". If the ",(0,a.kt)("inlineCode",{parentName:"p"},"type"),"s match, we actually don't have to remove the old element from the DOM and insert the new element; we can just update its properties. "),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"This is exactly what happens e.g., with the heading in the example. The ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," and the current ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber")," both have the same ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," (",(0,a.kt)("inlineCode",{parentName:"p"},"h1"),"), so we just update their properties.")),(0,a.kt)("p",null,"However, if the ",(0,a.kt)("inlineCode",{parentName:"p"},"type"),"s do not match, we have to remove the old fiber from the DOM and insert the new one. For this we call the function ",(0,a.kt)("inlineCode",{parentName:"p"},"replaceFiberInDom")," which we already looked at in first level. If the ",(0,a.kt)("inlineCode",{parentName:"p"},"type"),"s match, we call the function ",(0,a.kt)("inlineCode",{parentName:"p"},"updateFiberInDom"),", at which we're going to take a look now."),(0,a.kt)("h3",{id:"the-updatefiberindom-function"},"The ",(0,a.kt)("inlineCode",{parentName:"h3"},"updateFiberInDom")," function"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function updateFiberInDom(fiber: StaticFiber, container: HTMLElement, previousVersion: Fiber, nextSibling?: Fiber) {\n    // Get DOM node from previous version\n    const domNode = previousVersion.domNode\n    if (!domNode) throw new Error('Could not update fiber, previous domNode was not set.')\n    fiber.domNode = domNode\n\n    // Update all props on DOM node\n    updateDomNode(domNode, previousVersion?.props, fiber.props)\n\n    // If the order has changed, the element has to be reinserted at correct position.\n    // Note that insertBefore takes care of removing the element from the DOM before\n    // re-inserting it, so it's not needed to remove it manually.\n    if (nextSibling && domNode.nextSibling !== nextSibling?.domNode) {\n        container.insertBefore(domNode, nextSibling?.domNode ?? null)\n    }\n}\n")),(0,a.kt)("p",null,"What happens first, is that the reference to the ",(0,a.kt)("inlineCode",{parentName:"p"},"domNode")," of the ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," is copied to the new ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber"),". If the ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," does not have a ",(0,a.kt)("inlineCode",{parentName:"p"},"domNode"),", something went terribly wrong as this should never happen, so we just throw an error."),(0,a.kt)("p",null,"Next, we call the function ",(0,a.kt)("inlineCode",{parentName:"p"},"updateDomNode"),", which we also took a look at in the first level. It will remove all properties from the ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," and set all properties of the current ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber")," on the ",(0,a.kt)("inlineCode",{parentName:"p"},"domNode"),"."),(0,a.kt)("p",null,"The last lines make sure, that the ",(0,a.kt)("inlineCode",{parentName:"p"},"domNode")," is still at the correct position. Normally, we don't have to call ",(0,a.kt)("inlineCode",{parentName:"p"},"container.insertBefore")," again, as the ",(0,a.kt)("inlineCode",{parentName:"p"},"domNode")," is already rendered in the DOM. But if the order of the elements has changed, we sometimes have to call it again, to ensure to correct order. Note that ",(0,a.kt)("inlineCode",{parentName:"p"},"insertBefore")," will automatically remove the element from the DOM in case it's already present, and then insert it again at the correct positon."),(0,a.kt)("h3",{id:"revisiting-the-expandchildfibers-function"},"Revisiting the ",(0,a.kt)("inlineCode",{parentName:"h3"},"expandChildFibers")," Function"),(0,a.kt)("p",null,"Returning to the last line of ",(0,a.kt)("inlineCode",{parentName:"p"},"renderFiber"),", we see that the call to the function ",(0,a.kt)("inlineCode",{parentName:"p"},"expandChildFibers")," still stays the same. The only change is that the ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," is now no longer ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined"),". So let's take a look at the updated implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"expandChildFibers"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function expandChildFibers(fiber: StaticFiber, previousVersion?: Fiber) {\n    const currentChildren = fiber.children\n    // highlight-next-line\n    const previousChildren = previousVersion?.children ?? new Map<string, Fiber>()\n\n    // If the domNode of the container is not a HTMLElement, no children can be added to it.\n    const container = fiber.domNode\n    if (!container || !isHTMLElement(container)) return\n\n    // highlight-start\n    // First, remove all previousChildren from the DOM, which don't exist in the currentChildren.\n    previousChildren.forEach((previousChild, key) => {\n        if (currentChildren.get(key) === undefined) previousChild.domNode?.remove()\n    })\n    // highlight-end\n\n    // Go through all currentChildren and render them to the DOM.\n    // highlight-next-line\n    // The previous version is passed to determine the differences between the two versions.\n    // The nextChildSibling is used to enforce the correct order in the DOM.\n    // The order is reversed, to determine the nextChildSibling easily (to use insertBefore API).\n    let nextChildSibling: Fiber | undefined\n    const reversedChildren = Array.from(currentChildren.entries()).reverse()\n    reversedChildren.forEach(([key, currentChild]) => {\n        // highlight-start\n        const previousChild = previousChildren.get(key)\n        renderFiber(currentChild, container, previousChild, nextChildSibling)\n        // highlight-end\n        nextChildSibling = currentChild\n    })\n}\n")),(0,a.kt)("p",null,"This function tries to find the correct children from the ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," and match them with the children of the current ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber"),". The children of a fiber are matched via their key in the ",(0,a.kt)("inlineCode",{parentName:"p"},"children")," map. If no ",(0,a.kt)("inlineCode",{parentName:"p"},"key")," was explicitly set in the props, the framework just assigns the keys in the order they were in the SJDON array."),(0,a.kt)("p",null,"First, we go through all the ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion"),"'s children which don't have a match in the current ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber"),". This happens with the condition ",(0,a.kt)("inlineCode",{parentName:"p"},"currentChildren.get(key) === undefined"),". Those children are directly removed from the DOM. "),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"E.g., this would happen when the ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion"),"s SJDON structure looked something like ",(0,a.kt)("inlineCode",{parentName:"p"},"['div', ['p', 'first'], ['p', 'second']]")," and the current version is ",(0,a.kt)("inlineCode",{parentName:"p"},"['div', ['p', 'first']]"),". The ",(0,a.kt)("inlineCode",{parentName:"p"},"['p', 'second']")," element does not have a match and is directly removed from the DOM.")),(0,a.kt)("p",null,"In the loop at the end of the function, we go through the ",(0,a.kt)("inlineCode",{parentName:"p"},"children")," of the ",(0,a.kt)("inlineCode",{parentName:"p"},"currentFiber")," and recursively call the ",(0,a.kt)("inlineCode",{parentName:"p"},"renderFiber")," function. But first we try to find the child with the same key from the ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion"),". If it exists, it is passed as the third parameter, otherwise it is ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"If the SJDON structure of ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," was ",(0,a.kt)("inlineCode",{parentName:"p"},"['div', ['p', 'first']]")," and the current version is ",(0,a.kt)("inlineCode",{parentName:"p"},"['div', ['p', 'FIRST'], ['p', 'SECOND']]")," the following would happen: For the child ",(0,a.kt)("inlineCode",{parentName:"p"},"['p', 'FIRST']")," there is a match in the ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion"),", namely ",(0,a.kt)("inlineCode",{parentName:"p"},"['p', 'first']"),", which will be passed as the ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," to the ",(0,a.kt)("inlineCode",{parentName:"p"},"renderFiber")," function. For the child ",(0,a.kt)("inlineCode",{parentName:"p"},"['p', 'SECOND']")," there is no match, so ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined")," is passed as the parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," (because ",(0,a.kt)("inlineCode",{parentName:"p"},"previousChild.get(key)")," returns ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined"),").")),(0,a.kt)("p",null,"That's it, we've discussed the whole re-rendering process of the ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," hook. Feel free to go through the steps again, as it was a lot: From the ",(0,a.kt)("inlineCode",{parentName:"p"},"setState")," function which calls ",(0,a.kt)("inlineCode",{parentName:"p"},"rerenderFunctionalFiber"),". There, we make use of the parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," of the ",(0,a.kt)("inlineCode",{parentName:"p"},"renderFiber")," function. We're comparing the versions and calling ",(0,a.kt)("inlineCode",{parentName:"p"},"replaceFiberInDom")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"updateFiberInDom")," depending on the case. Afterwards, we recursively go through all the children with ",(0,a.kt)("inlineCode",{parentName:"p"},"expandChildFibers"),"."),(0,a.kt)("h2",{id:"the-useeffect-hook"},"The ",(0,a.kt)("inlineCode",{parentName:"h2"},"useEffect")," Hook"),(0,a.kt)("p",null,"With that, we can now look into the implementation of the second hook available in SuiWeb, which is ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export function useEffect(action: () => void, dependencies?: unknown[]) {\n    let shouldCallAction = false\n\n    if (dependencies !== undefined) {\n        // The state at the current index indicates, whether the first render has\n        // happend. If this is the first render, the effect should be executed.\n        const isFirstRender = states[stateIndex] !== true\n        if (isFirstRender) {\n            shouldCallAction = true\n            // `true` indicates, that the first render has happened\n            states[stateIndex] = true\n        }\n        // After the first-render-check, go to the next state-index\n        stateIndex++\n    } else {\n        // There are no dependencies, so the action is called on every render\n        shouldCallAction = true\n    }\n\n    dependencies?.forEach(dependency => {\n        // Check whether the captured value in the hook is different\n        // from the current value in the dependencies\n        if (dependency !== states[stateIndex]) {\n            shouldCallAction = true\n        }\n        states[stateIndex] = dependency\n        stateIndex++\n    })\n\n    // If any criteria for a re-render is met, run `action`\n    if (shouldCallAction) setTimeout(action)\n}\n")),(0,a.kt)("p",null,"For our ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," hook, we create just one local variable ",(0,a.kt)("inlineCode",{parentName:"p"},"shouldCallAction"),", with an initial value of ",(0,a.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,a.kt)("p",null,"Then, we will check if there is something defined for the parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"dependencies")," (this could also be an empty array ",(0,a.kt)("inlineCode",{parentName:"p"},"[]"),"), to get the intended functionality as described in the ",(0,a.kt)("a",{parentName:"p",href:"#using-hooks"},"Using Hooks")," section of this level. If we have some value assigned for ",(0,a.kt)("inlineCode",{parentName:"p"},"dependencies"),", we check whether the component has already been rendered once. To do so, we check if the current ",(0,a.kt)("em",{parentName:"p"},"state")," (retrieved by accessing the global ",(0,a.kt)("inlineCode",{parentName:"p"},"states")," array at ",(0,a.kt)("inlineCode",{parentName:"p"},"stateIndex"),") is not equal to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),". In that case, we set ",(0,a.kt)("inlineCode",{parentName:"p"},"shouldCallAction")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),", as this matches the criteria that the action of an effect should always be called for the first render. Additionally, we set the ",(0,a.kt)("inlineCode",{parentName:"p"},"states[stateIndex]")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),", such that ",(0,a.kt)("inlineCode",{parentName:"p"},"isFirstRender")," will be ",(0,a.kt)("inlineCode",{parentName:"p"},"false")," when this hook is executed in the next rendering cycle. Then, we increment ",(0,a.kt)("inlineCode",{parentName:"p"},"stateIndex"),", as we inserted an extra item in our ",(0,a.kt)("inlineCode",{parentName:"p"},"states")," array which stores whether the component has already been rendered."),(0,a.kt)("p",null,"If we haven't defined any dependencies when calling ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"shouldCallAction")," will always be ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),", and it's therefore also not needed to insert an extra value into ",(0,a.kt)("inlineCode",{parentName:"p"},"states")," to indicate whether the first rendering of the component has already been done."),(0,a.kt)("p",null,"Now, we go through all values in ",(0,a.kt)("inlineCode",{parentName:"p"},"dependencies")," and check, whether their value has changed to what is stored in ",(0,a.kt)("inlineCode",{parentName:"p"},"states[stateIndex]"),". If this is the case, we set ",(0,a.kt)("inlineCode",{parentName:"p"},"shouldCallAction")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),", as if one of its dependency has changed, the action of an effect should be called. Then, we set the value of the current ",(0,a.kt)("inlineCode",{parentName:"p"},"dependency")," in the loop to our ",(0,a.kt)("inlineCode",{parentName:"p"},"states[stateIndex]"),", which allows detecting if the value of the ",(0,a.kt)("inlineCode",{parentName:"p"},"dependency")," has changed on subsequent calls to ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," and increment ",(0,a.kt)("inlineCode",{parentName:"p"},"stateIndex"),"."),(0,a.kt)("p",null,"In the last line of ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect"),", we check if for all the conditions which were checked in the previous lines of the function, ",(0,a.kt)("inlineCode",{parentName:"p"},"shouldCallAction")," has been set to ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," anywhere. In that case, ",(0,a.kt)("inlineCode",{parentName:"p"},"action")," will be executed. Note that we use ",(0,a.kt)("inlineCode",{parentName:"p"},"setTimeout(action)")," to make sure that ",(0,a.kt)("inlineCode",{parentName:"p"},"action")," is executed ",(0,a.kt)("em",{parentName:"p"},"after")," the component has been rendered, as ",(0,a.kt)("inlineCode",{parentName:"p"},"setTimeout")," without specifying a delay, will run the function on the next event cycle. This is needed as per definition, the actions of an effect should be called ",(0,a.kt)("em",{parentName:"p"},"after")," rendering of a component has finished."),(0,a.kt)("h2",{id:"review"},"Review"),(0,a.kt)("p",null,"With that, we finished the level on hooks, and you should now know how to use them, as well as how they work internally. Hooks are probably one of the most important concepts of React, that make it very powerful."),(0,a.kt)("p",null,"In the ",(0,a.kt)("a",{parentName:"p",href:"/docs/tutorial/5-parsing-jsx/"},"next level"),", we will look at how we can define our components using ",(0,a.kt)("inlineCode",{parentName:"p"},"JSX"),", the syntax that is also used by React to define components."))}h.isMDXComponent=!0}}]);