"use strict";(self.webpackChunksuiweb_website=self.webpackChunksuiweb_website||[]).push([[938],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=i.createContext({}),s=function(e){var t=i.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return i.createElement(p.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,p=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=s(n),m=a,h=d["".concat(p,".").concat(m)]||d[m]||c[m]||r;return n?i.createElement(h,o(o({ref:t},u),{},{components:n})):i.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[d]="string"==typeof e?e:a,o[1]=l;for(var s=2;s<r;s++)o[s]=n[s];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8041:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var i=n(7462),a=(n(7294),n(3905));const r={},o="Level 8: Wrapping Everything Up",l={unversionedId:"tutorial/8-wrap-up/README",id:"tutorial/8-wrap-up/README",title:"Level 8: Wrapping Everything Up",description:"Introduction",source:"@site/docs/tutorial/8-wrap-up/README.md",sourceDirName:"tutorial/8-wrap-up",slug:"/tutorial/8-wrap-up/",permalink:"/docs/tutorial/8-wrap-up/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"apiSidebar",previous:{title:"Level 7: Rendering a Dynamic Amount of Elements",permalink:"/docs/tutorial/7-dynamic-rendering/"},next:{title:"API Documentation",permalink:"/docs/api/"}},p={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Goal",id:"goal",level:2},{value:"<code>index.js</code>",id:"indexjs",level:3},{value:"First Rendering of our App",id:"first-rendering-of-our-app",level:2},{value:"Parsing SJDON",id:"parsing-sjdon",level:3},{value:"Rendering the Root Fiber",id:"rendering-the-root-fiber",level:3},{value:"Re-Rendering Due to a Change in a State",id:"re-rendering-due-to-a-change-in-a-state",level:3},{value:"Review",id:"review",level:2}],u={toc:s};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"level-8-wrapping-everything-up"},"Level 8: Wrapping Everything Up"),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"Now that we have looked at all the functionality SuiWeb provides, we are going to look at all the calls that happen when we render an app with SuiWeb. We will no longer look into the implementations of the functions, but just at the order, in which they are called."),(0,a.kt)("h2",{id:"goal"},"Goal"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://suiweb.github.io/demos/tutorial/08-wrap-up/index.html"},"Demo")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/suiweb/suiweb/tree/main/demos/tutorial/08-wrap-up"},"Source Code"))),(0,a.kt)("p",null,"The demo we set up for this level consists of three components, ",(0,a.kt)("inlineCode",{parentName:"p"},"App"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"DateComponent")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter"),". The component ",(0,a.kt)("inlineCode",{parentName:"p"},"App")," returns a ",(0,a.kt)("inlineCode",{parentName:"p"},"h1")," title, a ",(0,a.kt)("inlineCode",{parentName:"p"},"DateCompoennt")," and a ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter"),", which are all wrapped in a ",(0,a.kt)("inlineCode",{parentName:"p"},"div"),". The ",(0,a.kt)("inlineCode",{parentName:"p"},"DateCompoent")," returns a string which contains a timestamp of the date when it was rendered. In the ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," component, we return another ",(0,a.kt)("inlineCode",{parentName:"p"},"DateComponent")," and a ",(0,a.kt)("inlineCode",{parentName:"p"},"button")," showing the amount of times it has been clicked. The ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," component is also wrapped in a ",(0,a.kt)("inlineCode",{parentName:"p"},"div"),", which has a ",(0,a.kt)("inlineCode",{parentName:"p"},"backgroundColor")," of ",(0,a.kt)("inlineCode",{parentName:"p"},"Aquamarine"),". This helps us to better see what is contained inside this component."),(0,a.kt)("p",null,"If you click the button, you can see that its count is incremented. As this changes the state of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," component, it will be re-rendered and thus the ",(0,a.kt)("inlineCode",{parentName:"p"},"DateComponent")," inside ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," will be re-executed, resulting in its timestamp being updated. If you look at the console, you can see that an effect is called every time the button is clicked, as the ",(0,a.kt)("inlineCode",{parentName:"p"},"count")," constant changes."),(0,a.kt)("p",null,"As the other ",(0,a.kt)("inlineCode",{parentName:"p"},"DateComponent")," is added inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"App")," component, it will ",(0,a.kt)("em",{parentName:"p"},"not")," be re-rendered if the button is clicked, as the state of the button is not defined in ",(0,a.kt)("inlineCode",{parentName:"p"},"App"),". This illustrates that only the components (and their subcomponents) are re-rendered that contain a state that has changed."),(0,a.kt)("p",null,"Below, you can see the source code of our ",(0,a.kt)("inlineCode",{parentName:"p"},"index.js"),". Our ",(0,a.kt)("inlineCode",{parentName:"p"},"index.html")," is again the same as in all other levels that used SJDON."),(0,a.kt)("h3",{id:"indexjs"},(0,a.kt)("inlineCode",{parentName:"h3"},"index.js")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"import { createElement } from '../../lib/js/fiber.js'\nimport { useEffect, useState } from '../../lib/js/hooks.js'\nimport { render } from '../../lib/js/render.js'\nimport { parseSjdon } from '../../lib/js/sjdon.js'\n\n\nconst App = () => {\n    return [\n        'div',\n        ['h1', 'Wrap Up'],\n        [DateComponent],\n        [Counter]\n    ]\n}\n\nconst DateComponent = () => {\n    return [\n        'p', \n        'If value changed, the component was rerendered: ', ['strong', Date.now()],\n    ]\n}\n\nconst Counter = () => {\n    const [count, setCount] = useState(0)\n\n    useEffect(\n        () => console.log(`The value of count has changed: ${count}`),\n        [count]\n    )\n\n    return [\n        'div', \n        { \n            style: {\n                backgroundColor: 'Aquamarine',\n                padding: '1rem'\n            }\n        },\n        [\n            'button', \n            { onclick: () => setCount(count + 1) }, \n            `Clicked ${count} times`\n        ],\n        [DateComponent]\n    ]\n}\n\nconst rootFiber = parseSjdon([App], createElement)\n\nrender(rootFiber, document.getElementById('app'))\n")),(0,a.kt)("h2",{id:"first-rendering-of-our-app"},"First Rendering of our App"),(0,a.kt)("p",null,"We will create a list representing the order of functions that are called for all the calls that happen when rendering ",(0,a.kt)("inlineCode",{parentName:"p"},"App")," the first time."),(0,a.kt)("h3",{id:"parsing-sjdon"},"Parsing SJDON"),(0,a.kt)("p",null,"First, let's see the calls needed to parse our SJDON array into ",(0,a.kt)("inlineCode",{parentName:"p"},"Fiber"),"s."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"const rootFiber = parseSjdon([App], createElement)")," to create fibers from SJDON",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"If ",(0,a.kt)("inlineCode",{parentName:"li"},"typeof type == 'string'"),", we call ",(0,a.kt)("inlineCode",{parentName:"li"},"createElement(type, props, ...parsedChildren")),(0,a.kt)("li",{parentName:"ul"},"Else we call ",(0,a.kt)("inlineCode",{parentName:"li"},"createElement(fiberFunction, props)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"We do the same for all children of the fiber"))))),(0,a.kt)("h3",{id:"rendering-the-root-fiber"},"Rendering the Root Fiber"),(0,a.kt)("p",null,"We call ",(0,a.kt)("inlineCode",{parentName:"p"},"render(rootFiber, document.getElementById('app'))")," using our now parsed root fiber and a reference to the container in which we want to render the root fiber. We will make sure in this function that all other elements contained inside our container will be removed. Then, we start with the actual rendering."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"renderFiber(fiber, container)"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"unwrapFunctionalFiber(fiber, container)")," if the fiber which we want to render is a ",(0,a.kt)("inlineCode",{parentName:"li"},"FunctionalFiber"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"prepareToUseHooks(fiber.memorizedStates, () => rerenderFunctionalFiber(fiber, container)")," to setup hooks, register the re-render function for the component"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"fiber.fiberFunction(fiber.functionProps)")," to execute functional fibers",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Calls to ",(0,a.kt)("inlineCode",{parentName:"li"},"useState")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"useEffect")," of the that fiber are made"),(0,a.kt)("li",{parentName:"ul"},"Actions of ",(0,a.kt)("inlineCode",{parentName:"li"},"useEffect")," calls are scheduled for next event cycle using ",(0,a.kt)("inlineCode",{parentName:"li"},"setTimeout(action)")))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Object.assign(fiber, unwrappedFiber)")," to merge the original functional fiber with its unwrapped version, while keeping the same object"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"replaceFiberInDom(fiber, container)")," as there is no previous version of our fiber, thus ",(0,a.kt)("inlineCode",{parentName:"li"},"areSameType")," will always be false for the initial rendering",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"createDomNode(fiber)")," to create an HTML element from our fiber"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"container.insertBefore(newDomNode, nextSibling?.domNode ?? null)")," to add our HTML element to the DOM"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"expandChildFibers(fiber)")," to go through all the children of the fiber we pass",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"renderFiber(currentChild, container, previousChild, nextChildSibling)")," ",(0,a.kt)("strong",{parentName:"li"},"for each child, repeat all the steps in this list")))))),(0,a.kt)("li",{parentName:"ul"},"Actions of ",(0,a.kt)("inlineCode",{parentName:"li"},"useEffect")," calls are executed when rendering has finished, as the next event cycle starts then")),(0,a.kt)("h3",{id:"re-rendering-due-to-a-change-in-a-state"},"Re-Rendering Due to a Change in a State"),(0,a.kt)("p",null,"Imagine what happens now when we click the button inside our ",(0,a.kt)("inlineCode",{parentName:"p"},"Counter")," component, which calls ",(0,a.kt)("inlineCode",{parentName:"p"},"setCount(count + 1)"),", that corresponds to the ",(0,a.kt)("inlineCode",{parentName:"p"},"setState")," function of our ",(0,a.kt)("inlineCode",{parentName:"p"},"counter")," state."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Set the new value passed to ",(0,a.kt)("inlineCode",{parentName:"li"},"setState")," inside ",(0,a.kt)("inlineCode",{parentName:"li"},"capturedStates")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"capturedRerender()")," to execute the re-render function that was captured inside the ",(0,a.kt)("inlineCode",{parentName:"li"},"setState")," closure before and registered using ",(0,a.kt)("inlineCode",{parentName:"li"},"prepareToUseHooks"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"rerenderFunctionalFiber(fiber, container)")," is called, as this was stored inside the ",(0,a.kt)("inlineCode",{parentName:"li"},"capturedRerender")," closure",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"renderFiber(fiber, container, previousVersion)")," to re-render the fiber",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"unwrapFunctionalFiber(fiber, container, previousVersion)")," ",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Copy over the ",(0,a.kt)("inlineCode",{parentName:"li"},"memorizedStates")," array of ",(0,a.kt)("inlineCode",{parentName:"li"},"previousVersion")," to the new fiber "),(0,a.kt)("li",{parentName:"ul"},"Re-execute the fiber's ",(0,a.kt)("inlineCode",{parentName:"li"},"fiberFunction"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Calls to ",(0,a.kt)("inlineCode",{parentName:"li"},"useState")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"useEffect")," of the that fiber are made (state now contains updated values)"),(0,a.kt)("li",{parentName:"ul"},"Actions of ",(0,a.kt)("inlineCode",{parentName:"li"},"useEffect")," calls are scheduled for next event cycle using ",(0,a.kt)("inlineCode",{parentName:"li"},"setTimeout(action)"),", if one of the effects dependencies has changed"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Object.assign(fiber, unwrappedFiber)")," to merge the original functional fiber with its unwrapped version, while keeping the same object"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"const areSameType = fiber && previousVersion && fiber.type === previousVersion.type")," to check whether the new fiber is of the same type as its previous version was",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"If ",(0,a.kt)("inlineCode",{parentName:"li"},"areSameType"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"updateFiberInDom(fiber, container, previousVersion, nextSibling)"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"updateDomNode(domNode, previousVersion?.props, fiber.props)")," to update the HTML element that already exists on the DOM with its new props"),(0,a.kt)("li",{parentName:"ul"},"If the order of the element has changed, re-insert the element in the DOM (which automatically removes the element at its other position in the DOM) by calling ",(0,a.kt)("inlineCode",{parentName:"li"},"container.insertBefore(domNode, nextSibling?.domNode ?? null)")))),(0,a.kt)("li",{parentName:"ul"},"Else ",(0,a.kt)("inlineCode",{parentName:"li"},"replaceFiberInDom(fiber, container, previousVersion, nextSibling)"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"createDomNode(fiber)")," to create an HTML element from our fiber"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"container.insertBefore(newDomNode, nextSibling?.domNode ?? null)")," to add our HTML element to the DOM"))))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"expandChildFibers(fiber)")," to go through all the children of the fiber we pass"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"renderFiber(currentChild, container, previousChild, nextChildSibling)")," ",(0,a.kt)("strong",{parentName:"li"},"for each child, start again from ",(0,a.kt)("inlineCode",{parentName:"strong"},"renderFiber(fiber, container, previousVersion)"))))))),(0,a.kt)("li",{parentName:"ul"},"Actions of ",(0,a.kt)("inlineCode",{parentName:"li"},"useEffect")," calls are executed when rendering has finished, as the next event cycle starts then")),(0,a.kt)("h2",{id:"review"},"Review"),(0,a.kt)("p",null,"With that, the final level of this tutorial is coming to an end. The lists above, showing the order in which calls are made as part of rendering our fibers, might support you to get an idea how a whole rendering cycle works. It might be helpful to also look at the source code of SuiWeb, while going through the lists of calls that are made. We have realized ourselves that it's sometimes hard to understand which functions are called as part of a rendering cycle, when we analyzed the source code of React and ",(0,a.kt)("a",{parentName:"p",href:"https://pomb.us/build-your-own-react/"},"Build your own React"),", so we hope that this list can give you at least ",(0,a.kt)("em",{parentName:"p"},"some")," help to better understand this whole process."),(0,a.kt)("p",null,"We hope that this tutorial helped you to understand how you can use SuiWeb, but also how its functionality is achieved internally. If you like to build applications in that way, you might want to have a look at ",(0,a.kt)("a",{parentName:"p",href:"https://reactjs.org/"},"React"),", the framework whose concepts we tried to explain with SuiWeb. React comes with a lot of additional functionality and performance optimization, which make it much better suited for production ready applications."),(0,a.kt)("p",null,"Thanks for working through our tutorial \ud83d\ude42"))}d.isMDXComponent=!0}}]);