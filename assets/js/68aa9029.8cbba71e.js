"use strict";(self.webpackChunksuiweb_website=self.webpackChunksuiweb_website||[]).push([[288],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),u=o,m=d["".concat(s,".").concat(u)]||d[u]||h[u]||a;return n?r.createElement(m,i(i({ref:t},c),{},{components:n})):r.createElement(m,i({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:o,i[1]=l;for(var p=2;p<a;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},176:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var r=n(7462),o=(n(7294),n(3905));const a={},i="Level 2: Parsing Fibers from SJDON Notation",l={unversionedId:"tutorial/2-parsing-sjdon/README",id:"tutorial/2-parsing-sjdon/README",title:"Level 2: Parsing Fibers from SJDON Notation",description:"Introduction",source:"@site/docs/tutorial/2-parsing-sjdon/README.md",sourceDirName:"tutorial/2-parsing-sjdon",slug:"/tutorial/2-parsing-sjdon/",permalink:"/docs/tutorial/2-parsing-sjdon/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"apiSidebar",previous:{title:"Level 1: Rendering Static Elements",permalink:"/docs/tutorial/1-static-rendering/"},next:{title:"Level 3: Splitting Code Into Components",permalink:"/docs/tutorial/3-components/"}},s={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Goal",id:"goal",level:2},{value:"<code>index.js</code>",id:"indexjs",level:3},{value:"Structure of SJDON",id:"structure-of-sjdon",level:2},{value:"The <code>parseSjdon</code> Function",id:"the-parsesjdon-function",level:2},{value:"Review",id:"review",level:2}],c={toc:p};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"level-2-parsing-fibers-from-sjdon-notation"},"Level 2: Parsing Fibers from SJDON Notation"),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"After we have seen how fibers can be created using the ",(0,o.kt)("a",{parentName:"p",href:"/docs/api/internal/modules/fiber#createelement"},(0,o.kt)("inlineCode",{parentName:"a"},"createElement"))," function and then rendered to the DOM by calling the ",(0,o.kt)("a",{parentName:"p",href:"/docs/api/internal/modules/render#render"},(0,o.kt)("inlineCode",{parentName:"a"},"render"))," function, we will now look at a way to define the structure of our fibers with less boilerplate."),(0,o.kt)("h2",{id:"goal"},"Goal"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://suiweb.github.io/demos/tutorial/02-parsing-sjdon/index.html"},"Demo")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/suiweb/suiweb/tree/main/demos/tutorial/02-parsing-sjdon"},"Source Code"))),(0,o.kt)("p",null,"Do you remember the slightly more complex example from the previous level, where we always had to call ",(0,o.kt)("inlineCode",{parentName:"p"},"createElement")," for every ",(0,o.kt)("inlineCode",{parentName:"p"},"Fiber")," we wanted to create? By using the ",(0,o.kt)("inlineCode",{parentName:"p"},"parseSjdon")," function, which we will explore in this level, we can write the same thing a bit more universally, by defining the structure in the SJDON notation and parsing it afterwards."),(0,o.kt)("p",null,"For that, look at the ",(0,o.kt)("inlineCode",{parentName:"p"},"index.js")," file for this tutorial. Note that the ",(0,o.kt)("inlineCode",{parentName:"p"},"index.html")," is the same as in the previous level."),(0,o.kt)("h3",{id:"indexjs"},(0,o.kt)("inlineCode",{parentName:"h3"},"index.js")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { createElement } from '../../lib/js/fiber.js'\nimport { parseSjdon } from '../../lib/js/sjdon.js'\nimport { render } from '../../lib/js/render.js'\n\nconst sjdon = [\n    'div',\n    { style: {\n        height: '100vh',\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n    } },\n    [\n        'main',\n        { style: {\n            textAlign: 'center',\n            padding: '2rem'\n        } },\n        [\n            'h1', \n            { style: { color: 'Salmon' } }, \n            'Hello World'\n        ],\n        [\n            'h2', \n            { style: { color: 'Turquoise' } }, \n            'This is a Subtitle'\n        ],\n        [\n            'p', \n            null, \n            'And here follows a paragraph which contains some normal text.'\n        ]\n    ]\n]\n\nrender(\n    // highlight-next-line\n    parseSjdon(sjdon, createElement),\n    document.getElementById('app')\n)\n")),(0,o.kt)("p",null,"The goal for this level is to know the structure of SJDON and to understand how ",(0,o.kt)("inlineCode",{parentName:"p"},"parseSjdon")," works internally."),(0,o.kt)("h2",{id:"structure-of-sjdon"},"Structure of SJDON"),(0,o.kt)("p",null,"Let's consider the following JavaScript array:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const sjdon = [\n    'div',\n    { className: 'container' },\n    [ 'h1', { 'id': 'page-title' }, 'Welcome to SJDON' ],\n    [ 'p', 'SJDON stands for Simple JavaScript DOM Notation.' ]\n]\n")),(0,o.kt)("p",null,"The array is following the rules of a notation called ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/gburkert/sjdon"},"SJDON"),", which is an acronym for Simple JavaScript DOM Notation."),(0,o.kt)("p",null,"If you look at the following HTML code, you might be able to recognize that this is the representation of the SJDON code you've seen above."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<div class="container">\n    <h1 id="page-title">Welcome to SJDON</h1>\n    <p>SJDON stands for Simple JavaScript DOM Notation.</p>\n</div>\n')),(0,o.kt)("p",null,"The formal definition of SJDON is as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A text node is simply the string containing the text."),(0,o.kt)("li",{parentName:"ul"},"An element node is an array that first contains the element name as a string and then the child elements (text or element nodes, in the desired order) and attribute descriptions for the element node."),(0,o.kt)("li",{parentName:"ul"},"Attribute descriptions are objects whose attributes and values correspond directly to the attributes and values of the HTML element. All attributes of the element can be combined in one object or distributed among several objects.")),(0,o.kt)("h2",{id:"the-parsesjdon-function"},"The ",(0,o.kt)("inlineCode",{parentName:"h2"},"parseSjdon")," Function"),(0,o.kt)("p",null,"This transformation of the SJDON array to its HTML representation is achieved with the function ",(0,o.kt)("inlineCode",{parentName:"p"},"parseSjdon"),", at which we are going to have a closer look in this level."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"export function parseSjdon<T>([type, ...rest]: SjdonElement, create: CreateElementFunction<T>): T {\n    const propsArray = rest.filter(isSjdonProps)\n    const props: Props = Object.assign({}, ...propsArray)\n    const children = rest.filter(isSjdonChild)\n    const parsedChildren = children.map(child => (isSjdonElement(child) ? parseSjdon(child, create) : child))\n    return create(type, props, ...parsedChildren)\n}\n")),(0,o.kt)("p",null,"We can see that ",(0,o.kt)("inlineCode",{parentName:"p"},"parseSjdon")," expects two parameters:"),(0,o.kt)("p",null,"First, an array, which follows the requirements of ",(0,o.kt)("inlineCode",{parentName:"p"},"SjdownElement"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"export type SjdonElement = [SjdonElementType, ...(SjdonElementOrPrimitive | Props)[]]\n")),(0,o.kt)("p",null,"As its first entry, the array must contain an element of type ",(0,o.kt)("inlineCode",{parentName:"p"},"SjdonElementType"),". Looking at this definition, we find out that this means it either has to be a string which is a valid HTML tag name (as we've seen in the previous chapter already), or some property of type ",(0,o.kt)("inlineCode",{parentName:"p"},"SjdonElementFunction"),". For now, we'll focus on the first case only."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"export type SjdonElementType = keyof HTMLElementTagNameMap | SjdonElementFunction\n")),(0,o.kt)("p",null,"The following entries of the ",(0,o.kt)("inlineCode",{parentName:"p"},"SjdonElement")," array can either be another ",(0,o.kt)("inlineCode",{parentName:"p"},"SjdonElement"),", a ",(0,o.kt)("inlineCode",{parentName:"p"},"Primitive")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Props")," (which we have also already seen in the first level)."),(0,o.kt)("p",null,"We will not look in detail into all the type definitions here, as they are quite straight-forward, but if you're interested, you can of course always look them up in the source code of SuiWeb."),(0,o.kt)("p",null,"The second parameter of the ",(0,o.kt)("inlineCode",{parentName:"p"},"parseSjdon")," function, named ",(0,o.kt)("inlineCode",{parentName:"p"},"create")," needs to be of type ",(0,o.kt)("inlineCode",{parentName:"p"},"CreateElementFunction"),". In the first level, we've looked at such a function, the ",(0,o.kt)("inlineCode",{parentName:"p"},"createElement")," function. For this tutorial, we are actually going to use exactly that function. It would, however, be possible to use another function which satisfies the ",(0,o.kt)("inlineCode",{parentName:"p"},"CreateElementFunction")," type, e.g. the ",(0,o.kt)("inlineCode",{parentName:"p"},"React.createElement")," function to use SJDON with React. "),(0,o.kt)("p",null,"Looking at the actual implementation of ",(0,o.kt)("inlineCode",{parentName:"p"},"parseSjdon"),", we can see that the elements of the ",(0,o.kt)("inlineCode",{parentName:"p"},"rest")," array are filtered into ",(0,o.kt)("inlineCode",{parentName:"p"},"propsArray")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"children"),", using the functions ",(0,o.kt)("inlineCode",{parentName:"p"},"isSjdonProps")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"isSjdonChild"),". These are so called type-checker functions which determine if a given object satisfies the requirements of a specific type. You can see the implementation of the two functions below."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"function isSjdonProps(object: unknown): object is Props {\n    return typeof object === 'object' && !Array.isArray(object)\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"function isSjdonChild(object: unknown): object is SjdonElementOrPrimitive {\n    return isPrimitive(object) || isSjdonElement(object)\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"propsArray")," is then merged into the object ",(0,o.kt)("inlineCode",{parentName:"p"},"props"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: You might be wondering why we are using ",(0,o.kt)("inlineCode",{parentName:"p"},"Object.assign({}, ...propsArray)")," to create our ",(0,o.kt)("inlineCode",{parentName:"p"},"props")," object, instead of the spread operator. The reason is that the spread operator is only working if we want to spread properties of another ",(0,o.kt)("em",{parentName:"p"},"object")," into a new object. In this case, however, our properties are stored in an ",(0,o.kt)("em",{parentName:"p"},"array"),". That's why we have to use ",(0,o.kt)("inlineCode",{parentName:"p"},"Object.assign()")," with a new empty object (",(0,o.kt)("inlineCode",{parentName:"p"},"{}"),") as the target, which allows us to do the same thing.")),(0,o.kt)("p",null,"In the next step, all children which are ",(0,o.kt)("inlineCode",{parentName:"p"},"SjdonElement"),"s have to be recursively parsed. However, if the child is a ",(0,o.kt)("inlineCode",{parentName:"p"},"Primitive"),", nothing has to be done. We use the ",(0,o.kt)("inlineCode",{parentName:"p"},"isSjdonElement")," function, which is another type-checker function, to check whether a child is an ",(0,o.kt)("inlineCode",{parentName:"p"},"SjdonElement"),"."),(0,o.kt)("p",null,"That's it, we now have the ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," of the element, the ",(0,o.kt)("inlineCode",{parentName:"p"},"props")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"parsedChildren"),", which is everything we need to call the ",(0,o.kt)("inlineCode",{parentName:"p"},"create")," function. In our case we're calling ",(0,o.kt)("inlineCode",{parentName:"p"},"createElement(type, props, ...parsedChildren)"),"."),(0,o.kt)("h2",{id:"review"},"Review"),(0,o.kt)("p",null,"In this level, we have discovered how we can define static elements with the SJDON notation and then use the ",(0,o.kt)("inlineCode",{parentName:"p"},"parseSjdon")," function, introduced in this level, together with the ",(0,o.kt)("inlineCode",{parentName:"p"},"createElement")," function, introduced in the previous level, to create fibers, which can then be rendered to the DOM using the ",(0,o.kt)("inlineCode",{parentName:"p"},"render")," function."),(0,o.kt)("p",null,"With that, you are ready for ",(0,o.kt)("a",{parentName:"p",href:"/docs/tutorial/3-components/"},"level 3"),", where we'll explore how our fibers can contain dynamic contents using functions."))}d.isMDXComponent=!0}}]);