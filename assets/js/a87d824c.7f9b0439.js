"use strict";(self.webpackChunksuiweb_website=self.webpackChunksuiweb_website||[]).push([[139],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=i.createContext({}),d=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return i.createElement(s.Provider,{value:t},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=d(n),u=r,m=h["".concat(s,".").concat(u)]||h[u]||c[u]||a;return n?i.createElement(m,o(o({ref:t},p),{},{components:n})):i.createElement(m,o({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:r,o[1]=l;for(var d=2;d<a;d++)o[d]=n[d];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5312:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var i=n(7462),r=(n(7294),n(3905));const a={},o="Level 6: Conditionally Showing Elements",l={unversionedId:"tutorial/6-conditional-rendering/README",id:"tutorial/6-conditional-rendering/README",title:"Level 6: Conditionally Showing Elements",description:"Introduction",source:"@site/docs/tutorial/6-conditional-rendering/README.md",sourceDirName:"tutorial/6-conditional-rendering",slug:"/tutorial/6-conditional-rendering/",permalink:"/docs/tutorial/6-conditional-rendering/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"apiSidebar",previous:{title:"Level 5: Defining Components the React-Way with JSX",permalink:"/docs/tutorial/5-parsing-jsx/"},next:{title:"Level 7: Rendering a Dynamic Amount of Elements",permalink:"/docs/tutorial/7-dynamic-rendering/"}},s={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Goal",id:"goal",level:2},{value:"<code>index.js</code>",id:"indexjs",level:3},{value:"What Makes Conditional Rendering Difficult",id:"what-makes-conditional-rendering-difficult",level:2},{value:"The Idea of Placeholders",id:"the-idea-of-placeholders",level:2},{value:"Creating Placeholder Fibers",id:"creating-placeholder-fibers",level:3},{value:"Revisiting the <code>renderFiber</code> function",id:"revisiting-the-renderfiber-function",level:3},{value:"Conditional Rendering in JSX",id:"conditional-rendering-in-jsx",level:2},{value:"Review",id:"review",level:2}],p={toc:d};function h(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"level-6-conditionally-showing-elements"},"Level 6: Conditionally Showing Elements"),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Until now, the components we defined always returned the same sub elements, so it was not possible, for example, to return a part of a component only if a certain condition is met. In this level, we will look at the additions that are needed to allow exactly this."),(0,r.kt)("h2",{id:"goal"},"Goal"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://suiweb.github.io/demos/tutorial/06-conditional-rendering/index.html"},"Demo")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/suiweb/suiweb/tree/main/demos/tutorial/06-conditional-rendering"},"Source Code"))),(0,r.kt)("p",null,"Below you can see the source code for the demo of this level. The ",(0,r.kt)("inlineCode",{parentName:"p"},"index.html")," file will be the same again as in levels 1-4."),(0,r.kt)("h3",{id:"indexjs"},(0,r.kt)("inlineCode",{parentName:"h3"},"index.js")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"import { createElement } from '../../lib/js/fiber.js'\nimport { useState } from '../../lib/js/hooks.js'\nimport { render } from '../../lib/js/render.js'\nimport { parseSjdon } from '../../lib/js/sjdon.js'\n\n\nconst App = () => {\n    const [show , setShow] = useState(false)\n    \n    return [\n        'div',\n        [\n            'button', \n            `${ show ? 'Hide' : 'Show' } Text 1`, \n            { onclick: () => setShow(!show) }\n        ],\n        show && [TextField, { name: 'Text 1' }],\n        [TextField , { name: 'Text 2' }]\n    ]\n}\n\nconst TextField = props => {\n    const [text, setText] = useState(props?.initialValue ?? '')\n    return [\n        'div',\n        ['label', `${props?.name}: `,\n            [\n                'input',\n                {\n                    value: text,\n                    oninput: event => setText(event.target.value),\n                },\n            ],\n        ],\n        ['p', 'Value: ', ['strong', text]],\n    ]\n}\n\nrender(\n    parseSjdon([App], createElement), \n    document.getElementById('app')\n)\n")),(0,r.kt)("p",null,'If we render the component, we can see a button and a text field with a label "Text 2". If we click the button, a second text field with a label "Text 1" is inserted ',(0,r.kt)("em",{parentName:"p"},"before"),' the other text field. When we enter text into a text field, it will be shown below the text field, prefixed with the text "Value: ". Note that the value of the second text field will remain, even if the first text field is hidden and shown again. It will just change its position.'),(0,r.kt)("p",null,"We will not look in detail at the implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"TextField")," function, as it's a quite basic functional component using state, like we have already seen in previous demos."),(0,r.kt)("p",null,"We will, however, look into the implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"App")," component. In there, we can see that first, a button is defined, that has a different text depending on whether ",(0,r.kt)("inlineCode",{parentName:"p"},"show")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),". Then, we set an action for the ",(0,r.kt)("inlineCode",{parentName:"p"},"onclick")," event of the button, in which we call ",(0,r.kt)("inlineCode",{parentName:"p"},"setShow(!show)"),", which means that the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"show")," will be inverted on every button click."),(0,r.kt)("p",null,"In the following line, we can see some interesting syntax: ",(0,r.kt)("inlineCode",{parentName:"p"},"show && [TextField, { name: 'Text 1' }]"),". This pattern is actually used quite frequently in JavaScript. If you are not yet familiar with it, it will basically just equal ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," in case of any value being ",(0,r.kt)("em",{parentName:"p"},"falsy")," in the chain, or the last value otherwise. In other words, if we assigned this statement to a variable ",(0,r.kt)("inlineCode",{parentName:"p"},"const value = show && [TextField, { name: 'Text 1' }]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," would be ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"show == false")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"[TextField, { name: 'Text 1' }]")," otherwise. Note that nothing is rendered to the DOM if the value is ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),", meaning the text field is only shown if ",(0,r.kt)("inlineCode",{parentName:"p"},"show")," is ",(0,r.kt)("em",{parentName:"p"},"truthy"),"."),(0,r.kt)("p",null,"In the last line, another ",(0,r.kt)("inlineCode",{parentName:"p"},"TextField")," is added to the component, without any conditions."),(0,r.kt)("h2",{id:"what-makes-conditional-rendering-difficult"},"What Makes Conditional Rendering Difficult"),(0,r.kt)("p",null,"What might feel quite natural when using, is actually a bit more complicated once you think about what is needed to make this work under the hood."),(0,r.kt)("p",null,"You might remember that, in order to retain the ",(0,r.kt)("inlineCode",{parentName:"p"},"memorizedStates")," array of fibers between renderings, it is copied over from the previous version of that fiber. For that, we create a copy of the fiber inside ",(0,r.kt)("inlineCode",{parentName:"p"},"rerenderFunctionalFiber")," and use it as the previous version. Then, we also need to go through the previous versions of all children of that fiber, which we do in ",(0,r.kt)("inlineCode",{parentName:"p"},"expandChildFibers"),", as we can see in the excerpt of that function below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const reversedChildren = Array.from(currentChildren.entries()).reverse()\nreversedChildren.forEach(([key, currentChild]) => {\n    const previousChild = previousChildren.get(key)\n    renderFiber(currentChild, container, previousChild, nextChildSibling)\n})\n")),(0,r.kt)("p",null,"To determine the previous child which matches the ",(0,r.kt)("inlineCode",{parentName:"p"},"currentChild"),", we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"key")," at which the child is stored inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"currentChildren")," ",(0,r.kt)("inlineCode",{parentName:"p"},"Map"),". Remember that this key is determined automatically (if not defined explicitly) based on the order at which the child was added to its parent."),(0,r.kt)("p",null,"This means that in our example, the button would have the key ",(0,r.kt)("inlineCode",{parentName:"p"},"d-0")," (the ",(0,r.kt)("inlineCode",{parentName:"p"},"d-")," is prefixed to prevent overlap of explicit and default keys; explicit keys will be prefixed with ",(0,r.kt)("inlineCode",{parentName:"p"},"e-"),"), and the first text field that is shown ",(0,r.kt)("inlineCode",{parentName:"p"},"d-1"),". If there was a second text field, it would have the key ",(0,r.kt)("inlineCode",{parentName:"p"},"d-2"),". "),(0,r.kt)("p",null,"Maybe you can already see the problem which will now arise: Because the first text field is only shown under certain conditions, the key of the second text field would actually be different, depending on whether the first is shown or not (",(0,r.kt)("inlineCode",{parentName:"p"},"d-1")," if the first text field is hidden, ",(0,r.kt)("inlineCode",{parentName:"p"},"d-2")," if the first text field is shown). With that, matching of the current and previous version would no longer work. It would actually just copy over the ",(0,r.kt)("inlineCode",{parentName:"p"},"memorizedStates")," into the ",(0,r.kt)("em",{parentName:"p"},"first")," text field, as it receives the ",(0,r.kt)("inlineCode",{parentName:"p"},"d-1")," key. The state of the ",(0,r.kt)("em",{parentName:"p"},"second")," text field would be lost (moved to the first), because it receives the key ",(0,r.kt)("inlineCode",{parentName:"p"},"d-2")," which does not match with anything from the previous version."),(0,r.kt)("p",null,"But as you have seen, the problem described here does not actually occur in SuiWeb, so we will look how this is made possible in the following section."),(0,r.kt)("h2",{id:"the-idea-of-placeholders"},"The Idea of Placeholders"),(0,r.kt)("p",null,"You might remember from the example in the beginning of this level, we don't render anything if an entry inside an SJDON array is ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),". This does not mean, however, that this element is not ",(0,r.kt)("em",{parentName:"p"},"seen")," by the ",(0,r.kt)("inlineCode",{parentName:"p"},"createElement")," function."),(0,r.kt)("p",null,"The idea behind conditional rendering is that we create a special placeholder fiber in case that an element is ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),". We will then not render this placeholder fiber to the DOM, but keep its representation like every other fiber in our fiber tree. With that, we make sure that also placeholders will get a key, thus the count of elements will always be constant, which ensures that default keys remain the same between rendering cycles, even if some components are not always shown."),(0,r.kt)("p",null,"Now, let's look at the actual implementation of what we just described."),(0,r.kt)("h3",{id:"creating-placeholder-fibers"},"Creating Placeholder Fibers"),(0,r.kt)("p",null,"To see where those placeholder fibers are created, we need to revisit the ",(0,r.kt)("inlineCode",{parentName:"p"},"mapChildren")," function, at which we already looked at partly in ",(0,r.kt)("a",{parentName:"p",href:"/docs/tutorial/1-static-rendering/#mapping-children"},"level 1"),". The line that has been added is highlighted in the source code below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"function mapChildren(childrenRaw: (Fiber | Primitive)[]): Map<string, Fiber> {\n    const children = childrenRaw.map(child => {\n        // highlight-next-line\n        if (child == null || child === false) return createPlaceholderFiber()\n        else if (isPrimitive(child)) return createTextFiber(child)\n        else return child\n    })\n\n    // Use a Map to store children in, as this allows to set a custom key,\n    // while also guaranteeing to preserve the order of insertion (unlike object).\n    const childrenMap: Map<string, Fiber> = new Map()\n    let defaultKey = 0\n    children.forEach(child => {\n        const childProps = isFunctionalFiber(child) ? child.functionProps : child.props\n        // Keys are prefixed e-(xplicit) or d-(efault), so a custom key can never\n        // accidentally match a generated key.\n        const key = childProps?.key ? `e-${childProps?.key}` : `d-${defaultKey++}`\n        childrenMap.set(key, child)\n    })\n\n    return childrenMap\n}\n")),(0,r.kt)("p",null,"If the current ",(0,r.kt)("inlineCode",{parentName:"p"},"child")," in the loop is either ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),", a placeholder fiber will be created using the ",(0,r.kt)("inlineCode",{parentName:"p"},"createPlaceholderFiber")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"function createPlaceholderFiber(): StaticFiber {\n    return {\n        type: 'PLACEHOLDER_NODE',\n        props: {},\n        children: new Map(),\n    }\n}\n")),(0,r.kt)("p",null,"The function, that is quite similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"createTextFiber"),", returns an object of type ",(0,r.kt)("inlineCode",{parentName:"p"},"StaticFiber"),", which has a type of ",(0,r.kt)("inlineCode",{parentName:"p"},"PLACEHOLDER_NODE"),", an empty ",(0,r.kt)("inlineCode",{parentName:"p"},"props")," object and an empty ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"children"),". "),(0,r.kt)("h3",{id:"revisiting-the-renderfiber-function"},"Revisiting the ",(0,r.kt)("inlineCode",{parentName:"h3"},"renderFiber")," function"),(0,r.kt)("p",null,"Now that we have seen how and when placeholder fibers are created, we'll also look at the full implementation of ",(0,r.kt)("inlineCode",{parentName:"p"},"renderFiber"),", to see what we do with placeholder fibers there. The parts that are added are again highlighted in the code below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"function renderFiber(fiber: Fiber, container: HTMLElement, previousVersion?: Fiber, nextSibling?: Fiber) {\n    // If the component is a functional fiber, execute its fiberFunction\n    // to get the unwrapped StaticFiber properties merged into the same object.\n    if (isFunctionalFiber(fiber)) unwrapFunctionalFiber(fiber, container, previousVersion)\n\n    // After unwrapping, the fiber must contain all properties of a static fiber.\n    if (!isStaticFiber(fiber)) throw new Error('Fiber did not contain all StaticFiber properties after unwrapping.')\n\n    // highlight-start\n    // If the fiber is a placeholder, just remove the previous version, if exists.\n    if (fiber.type === 'PLACEHOLDER_NODE') {\n        fiber.domNode = undefined\n        previousVersion?.domNode?.remove()\n        return\n    }\n    // highlight-end\n\n    // Determines if the new fiber still has the same type as the old fiber.\n    const areSameType = fiber && previousVersion && fiber.type === previousVersion.type\n\n    // Got a fiber with the same type in the tree, so just update the contents of the DOM node.\n    if (areSameType) updateFiberInDom(fiber, container, previousVersion, nextSibling)\n    // The types did not match, create new DOM node and remove previous DOM node.\n    else replaceFiberInDom(fiber, container, previousVersion, nextSibling)\n\n    expandChildFibers(fiber, previousVersion)\n}\n")),(0,r.kt)("p",null,"As you can see, if the ",(0,r.kt)("inlineCode",{parentName:"p"},"fiber"),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," equals ",(0,r.kt)("inlineCode",{parentName:"p"},"PLACEHOLDER_NODE"),", its ",(0,r.kt)("inlineCode",{parentName:"p"},"domNode")," property is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"domNode")," of the ",(0,r.kt)("inlineCode",{parentName:"p"},"previousVersion")," will be removed, in case it exists. "),(0,r.kt)("p",null,"This case will apply in the example shown in the beginning of this tutorial when the first text field is shown, and then removed. In the rendering phase in which the text field is removed, its type will be ",(0,r.kt)("inlineCode",{parentName:"p"},"PLACEHOLDER_NODE"),", as we pass ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," instead of the text field. Thus, the HTML ",(0,r.kt)("inlineCode",{parentName:"p"},"input")," element, that has been added to the DOM during the previous rendering phase, needs to be removed from the DOM now."),(0,r.kt)("h2",{id:"conditional-rendering-in-jsx"},"Conditional Rendering in JSX"),(0,r.kt)("p",null,"Now that we have seen how conditional rendering works in SJDON, we will also have a brief look at how the concept works in JSX."),(0,r.kt)("p",null,"For that, let's look at the following example, which represents the component we've looked at in the beginning of this level, just in JSX."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { createElement } from '../../lib/js/fiber.js'\nimport { useState } from '../../lib/js/hooks.js'\nimport { render } from '../../lib/js/render.js'\n\n/** @jsx createElement */\n\nconst App = () => {\n    const [show , setShow] = useState(false)\n    \n    return (\n        <div>\n            <button onclick={() => setShow(!show)}>\n                {`${ show ? 'Hide' : 'Show' } Text 1`}\n            </button>\n            // highlight-next-line\n            {show && <TextField name=\"Text 1\" />}\n            <TextField name=\"Text 2\" />\n        </div>\n    )\n}\n\nconst TextField = props => {\n    const [text, setText] = useState(props?.initialValue ?? '')\n    return (\n        <div>\n            <label>\n                {props.name}\n                <input \n                    value={text} \n                    oninput={event => setText(event.target.value)} \n                />\n            </label>\n        </div>\n    )\n}\n\nrender(\n    <App />,\n    document.getElementById('app')\n)\n")),(0,r.kt)("p",null,"As you can see, the syntax works quite similar to SJDON. We also use the ",(0,r.kt)("inlineCode",{parentName:"p"},"&&")," to either return ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," or the ",(0,r.kt)("inlineCode",{parentName:"p"},"TextField")," component. Note that we need to wrap the statement in curly braces ",(0,r.kt)("inlineCode",{parentName:"p"},"{ ... }"),", as the code would otherwise not be valid JSX."),(0,r.kt)("h2",{id:"review"},"Review"),(0,r.kt)("p",null,"With that, we have looked at everything that is needed to render (or not render) elements based on simple conditions. There might, however, be cases where it will not be enough to have simple ",(0,r.kt)("inlineCode",{parentName:"p"},"if")," conditions that decide on whether an element will be rendered or not. Think of examples that render a dynamic amount of elements, that could change based on certain criteria. For that, we need a more advanced technique to identify individual components. This is what we are going to look at in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/tutorial/7-dynamic-rendering/"},"next level"),"."))}h.isMDXComponent=!0}}]);