"use strict";(self.webpackChunksuiweb_website=self.webpackChunksuiweb_website||[]).push([[316],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=i.createContext({}),s=function(e){var t=i.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return i.createElement(p.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=s(n),m=a,u=c["".concat(p,".").concat(m)]||c[m]||h[m]||r;return n?i.createElement(u,o(o({ref:t},d),{},{components:n})):i.createElement(u,o({ref:t},d))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[c]="string"==typeof e?e:a,o[1]=l;for(var s=2;s<r;s++)o[s]=n[s];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1467:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var i=n(7462),a=(n(7294),n(3905));const r={},o="Level 1: Rendering Static Elements",l={unversionedId:"tutorial/1-static-rendering/README",id:"tutorial/1-static-rendering/README",title:"Level 1: Rendering Static Elements",description:"Introduction",source:"@site/docs/tutorial/1-static-rendering/README.md",sourceDirName:"tutorial/1-static-rendering",slug:"/tutorial/1-static-rendering/",permalink:"/docs/tutorial/1-static-rendering/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"apiSidebar",previous:{title:"Tutorial",permalink:"/docs/tutorial/"},next:{title:"Level 2: Parsing Fibers from SJDON Notation",permalink:"/docs/tutorial/2-parsing-sjdon/"}},p={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Goal",id:"goal",level:2},{value:"<code>index.html</code>",id:"indexhtml",level:3},{value:"<code>index.js</code>",id:"indexjs",level:3},{value:"The <code>createElement</code> Function",id:"the-createelement-function",level:2},{value:"Mapping Children",id:"mapping-children",level:3},{value:"Handling of Text Nodes",id:"handling-of-text-nodes",level:3},{value:"The <code>render</code> Function",id:"the-render-function",level:2},{value:"The <code>renderFiber</code> Function",id:"the-renderfiber-function",level:3},{value:"Creating DOM Nodes",id:"creating-dom-nodes",level:3},{value:"Updating DOM Nodes",id:"updating-dom-nodes",level:3},{value:"The <code>expandChildFibers</code> Function",id:"the-expandchildfibers-function",level:3},{value:"Review",id:"review",level:2},{value:"More Advanced Example",id:"more-advanced-example",level:3}],d={toc:s};function c(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"level-1-rendering-static-elements"},"Level 1: Rendering Static Elements"),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"In the first level of the tutorial, we're going to have a look at the ",(0,a.kt)("a",{parentName:"p",href:"/docs/api/internal/modules/render#render"},(0,a.kt)("inlineCode",{parentName:"a"},"render"))," and the ",(0,a.kt)("a",{parentName:"p",href:"/docs/api/internal/modules/fiber#createelement"},(0,a.kt)("inlineCode",{parentName:"a"},"createElement"))," function of SuiWeb and see how they can be used to render a simple element to the DOM."),(0,a.kt)("h2",{id:"goal"},"Goal"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://suiweb.github.io/demos/tutorial/01-static-rendering/index.html"},"Demo")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/suiweb/suiweb/tree/main/demos/tutorial/01-static-rendering"},"Source Code"))),(0,a.kt)("p",null,"We will explore what a ",(0,a.kt)("inlineCode",{parentName:"p"},"Fiber")," is, how it can be created and how it can then be rendered to the DOM. For that, we set up a project containing SuiWeb in a directory called ",(0,a.kt)("inlineCode",{parentName:"p"},"lib"),", as explained in the ",(0,a.kt)("a",{parentName:"p",href:"/docs/getting-started"},"getting started guide"),"."),(0,a.kt)("p",null,"Additionally, we'll have to create two files, ",(0,a.kt)("inlineCode",{parentName:"p"},"index.html")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"index.js"),", as described below. Alternatively, you can also download the source code of this level with the link at the beginning of the section."),(0,a.kt)("h3",{id:"indexhtml"},(0,a.kt)("inlineCode",{parentName:"h3"},"index.html")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html"},'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>SuiWeb App</title>\n    <script type="module" src="index.js"><\/script>\n</head>\n<body>\n    <noscript>You need to enable JavaScript to run this app.</noscript>\n    <div id="app"></div>\n</body>\n</html>\n')),(0,a.kt)("p",null,"Unless stated differently in a level, the ",(0,a.kt)("inlineCode",{parentName:"p"},"index.html")," file will be the same for all future demos, as it just contains some static structure which is needed such that a SuiWeb app can be rendered inside it."),(0,a.kt)("h3",{id:"indexjs"},(0,a.kt)("inlineCode",{parentName:"h3"},"index.js")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"import { createElement } from '../../lib/js/fiber.js'\nimport { render } from '../../lib/js/render.js'\n\nconst fiber = createElement('h1', { style: { color: 'Salmon' } }, 'Hello World')\n\nrender(\n    fiber,\n    document.getElementById('app')\n)\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"index.js")," file is where the actual logic happens, namely two calls to the functions ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"render"),"."),(0,a.kt)("p",null,"If we run a local web server containing the following files, we should see a page containing a ",(0,a.kt)("inlineCode",{parentName:"p"},"h1")," title with the value \"Hello World\". If you think that it's pretty useless to render this simple HTML using some fancy JavaScript functions, and it would be much easier to just directly create this page in HTML, you're actually right. But it's important to understand how this works, because it will make it a lot easier to later understand how dynamic rendering works."),(0,a.kt)("p",null,"So, we'll now dive into the logic of those two functions and explore what happens under the hood."),(0,a.kt)("h2",{id:"the-createelement-function"},"The ",(0,a.kt)("inlineCode",{parentName:"h2"},"createElement")," Function"),(0,a.kt)("p",null,"To call the ",(0,a.kt)("inlineCode",{parentName:"p"},"render")," function of SuiWeb, we need to pass it some object of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Fiber"),". A fiber is nothing more than a JavaScript object, which contains the necessary properties such that the render function can later create an HTML element from it and render it to the DOM. We call it ",(0,a.kt)("inlineCode",{parentName:"p"},"Fiber"),", as this is the name that is also used in ",(0,a.kt)("inlineCode",{parentName:"p"},"React")," for this type of objects."),(0,a.kt)("p",null,"When looking at the type definition of ",(0,a.kt)("inlineCode",{parentName:"p"},"Fiber"),", we can see that it's actually just an alias to describe that the object is either of type ",(0,a.kt)("inlineCode",{parentName:"p"},"StaticFiber")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"FunctionalFiber"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export type Fiber = StaticFiber | FunctionalFiber\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"For this level, we'll just look at ",(0,a.kt)("inlineCode",{parentName:"p"},"StaticFibers"),", so you can consider ",(0,a.kt)("inlineCode",{parentName:"p"},"Fiber")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"StaticFiber")," to be the same type for now.")),(0,a.kt)("p",null,"To create a new ",(0,a.kt)("inlineCode",{parentName:"p"},"Fiber"),", we utilize the ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement")," function of SuiWeb. Later, you would actually not call this method by yourself. Instead, this is the method that is called by a tool like ",(0,a.kt)("a",{parentName:"p",href:"https://babeljs.io/"},"Babel")," when transforming JSX to normal JavaScript, or the ",(0,a.kt)("inlineCode",{parentName:"p"},"parseSjdon")," function of SuiWeb. But for now, we'll use it directly, as it helps to then also understand how the other methods described work."),(0,a.kt)("p",null,"If we look at the definition of ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement"),", we can see that it expects a variable amount of parameters, namely a ",(0,a.kt)("inlineCode",{parentName:"p"},"type"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"props")," and a variable amount of ",(0,a.kt)("inlineCode",{parentName:"p"},"children"),". Note that inside this function, some parts have been left away in this example, as they are not yet relevant."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export const createElement: CreateElementFunction<Fiber> = (type, props, ...children) => {\n    const mappedChildren = mapChildren(children)\n    const safeProps = props ?? {}\n\n    return { type, props: safeProps, children: mappedChildren }\n}\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note: If you're wondering why this function is defined using the ",(0,a.kt)("inlineCode",{parentName:"p"},"const")," keyword, and not, like the other functions in this framework, using ",(0,a.kt)("inlineCode",{parentName:"p"},"function"),", it's because this function will later be used in a context where it should be interchangeable, such that it had to be ensured that it satisfies the ",(0,a.kt)("inlineCode",{parentName:"p"},"CreateElementFunction<T>")," type, which is only possible using this notation.")),(0,a.kt)("p",null,"By looking at the type of ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement"),", named ",(0,a.kt)("inlineCode",{parentName:"p"},"CreateElementFunction<T>"),", we can see the parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," can either be a key of ",(0,a.kt)("inlineCode",{parentName:"p"},"HTMLElementTagNameMap")," or some function. For now, we'll ignore the part that it could also be a function (",(0,a.kt)("inlineCode",{parentName:"p"},"((props?: Record<string, unknown>) => T)"),") and just focus on ",(0,a.kt)("inlineCode",{parentName:"p"},"HTMLElementTagNameMap"),". If you have ",(0,a.kt)("a",{parentName:"p",href:"https://code.visualstudio.com/docs/nodejs/working-with-javascript#_type-checking-javascript"},"enabled type checking")," for your file or project, this will make sure that ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," is a string, which is a valid HTML tag name, such as ",(0,a.kt)("inlineCode",{parentName:"p"},"div"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"h1"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"p")," or any other valid tag name. In case you entered an invalid string, such as ",(0,a.kt)("inlineCode",{parentName:"p"},"dif"),", the type checker would detect that the value is invalid and thus help you identify this error."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export type CreateElementFunction<T = Fiber> = (\n    type: keyof HTMLElementTagNameMap | ((props?: Record<string, unknown>) => T),\n    props: Props | null,\n    ...children: (T | Primitive)[]\n) => T\n")),(0,a.kt)("p",null,"Next, we have the parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"props")," of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Props"),". For now, we'll not look more closely into the type definition of ",(0,a.kt)("inlineCode",{parentName:"p"},"Props"),", but just say that it is some object which has some constraints on its properties."),(0,a.kt)("p",null,"As the last parameter, we have a variable amount of children, which are either of the generic type ",(0,a.kt)("inlineCode",{parentName:"p"},"T")," (which is typically equal to ",(0,a.kt)("inlineCode",{parentName:"p"},"Fiber")," in this context), or ",(0,a.kt)("inlineCode",{parentName:"p"},"Primitive"),", which basically just means it's either of type ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"number"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"boolean"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"symbol"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,a.kt)("h3",{id:"mapping-children"},"Mapping Children"),(0,a.kt)("p",null,"If we now go back to our ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement")," function, we see that the first call that is made goes to a function called ",(0,a.kt)("inlineCode",{parentName:"p"},"mapChildren"),", which takes as its parameter the array of children that were passed to ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function mapChildren(childrenRaw: (Fiber | Primitive)[]): Map<string, Fiber> {\n    const children = childrenRaw.map(child => {\n        if (isPrimitive(child)) return createTextFiber(child)\n        else return child\n    })\n\n    // Use a Map to store children in, as this allows to set a custom key,\n    // while also guaranteeing to preserve the order of insertion (unlike object).\n    const childrenMap: Map<string, Fiber> = new Map()\n    let defaultKey = 0\n    children.forEach(child => {\n        const childProps = isFunctionalFiber(child) ? child.functionProps : child.props\n        // Keys are prefixed e-(xplicit) or d-(efault), so a custom key can never\n        // accidentally match a generated key.\n        const key = childProps?.key ? `e-${childProps?.key}` : `d-${defaultKey++}`\n        childrenMap.set(key, child)\n    })\n\n    return childrenMap\n}\n")),(0,a.kt)("h3",{id:"handling-of-text-nodes"},"Handling of Text Nodes"),(0,a.kt)("p",null,"Looking at the function definition of ",(0,a.kt)("inlineCode",{parentName:"p"},"mapChildren"),", we can see that in case of a child being ",(0,a.kt)("inlineCode",{parentName:"p"},"Primitive")," (as explained before), ",(0,a.kt)("inlineCode",{parentName:"p"},"createTextFiber")," is called, which wraps the primitive value (named ",(0,a.kt)("inlineCode",{parentName:"p"},"text")," in the function parameter), into a special kind of ",(0,a.kt)("inlineCode",{parentName:"p"},"Fiber")," object, with the special type ",(0,a.kt)("inlineCode",{parentName:"p"},"TEXT_NODE"),". We'll explore later why this is needed."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function createTextFiber(text: NonNullable<Primitive>): StaticFiber {\n    return {\n        type: 'TEXT_NODE',\n        props: {\n            nodeValue: text.toString(),\n        },\n        children: new Map(),\n    }\n}\n")),(0,a.kt)("p",null,"What happens next inside ",(0,a.kt)("inlineCode",{parentName:"p"},"mapChildren")," is actually mostly about defining a unique key for each child element of a ",(0,a.kt)("inlineCode",{parentName:"p"},"Fiber"),". The key can either be specified explicitly as part of the ",(0,a.kt)("inlineCode",{parentName:"p"},"props")," object which is passed to the ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement")," function, or a default key will be generated, in case no explicit key is defined. The function will then return a ",(0,a.kt)("inlineCode",{parentName:"p"},"Map"),", which contains all the children with their corresponding key."),(0,a.kt)("p",null,"Going back to where we are in our ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement")," function, we can see that an empty object is assigned to ",(0,a.kt)("inlineCode",{parentName:"p"},"safeProps"),", in case of the parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"props")," being nullish. Then, a new object is returned, which contains the properties ",(0,a.kt)("inlineCode",{parentName:"p"},"type"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"props")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"children"),", while some properties have been transformed as described. This object is actually of type ",(0,a.kt)("inlineCode",{parentName:"p"},"StaticFiber"),". What we have not seen yet is the property ",(0,a.kt)("inlineCode",{parentName:"p"},"domNode"),", which will be set later in the rendering process."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * A `StaticFiber` represents a static element in the DOM. It does not contain\n * a function and thus can't use hooks, so it will never trigger a re-render.\n * It is completely defined by its `type`, `props` and `children`.\n * Its `domNode` will be assigned when it is rendered to the DOM.\n */\nexport type StaticFiber = {\n    /**\n     * The type of the static fiber.\n     * It is either a html tag or a custom tag for text or placeholder nodes.\n     */\n    type: StaticFiberType\n    /**\n     * The props of the static fiber. These will be added to them DOM node when it is rendered.\n     * There are special props like `key` which serve their custom purpose and are not added to the DOM node.\n     * @see {@link isNormalProp}\n     */\n    props: Readonly<Props>\n    /**\n     * The children of the fiber are stored in a map where every child has a unique key.\n     * If no `key` is provided in the `props` of the corresponding child, a default key is used.\n     */\n    children: Map<string, Fiber>\n    /**\n     * The reference to the DOM node which this fiber represents.\n     * Is only set when the fiber is rendered.\n     */\n    domNode?: HTMLElement | Text | undefined\n}\n")),(0,a.kt)("p",null,"That's it, you now know what a basic ",(0,a.kt)("inlineCode",{parentName:"p"},"StaticFiber")," looks like. "),(0,a.kt)("h2",{id:"the-render-function"},"The ",(0,a.kt)("inlineCode",{parentName:"h2"},"render")," Function"),(0,a.kt)("p",null,"Next, we'll have a look at how such a ",(0,a.kt)("inlineCode",{parentName:"p"},"Fiber")," can now be rendered to the DOM."),(0,a.kt)("p",null,"For that, let's have a look at the definition of the ",(0,a.kt)("inlineCode",{parentName:"p"},"render")," function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export function render(fiber: Fiber, container: HTMLElement) {\n    while (container.firstChild) container.firstChild?.remove()\n    // No previous version is specified, as it is the first render.\n    renderFiber(fiber, container)\n}\n")),(0,a.kt)("p",null,"We can see that it expects two parameters. The first parameter named ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber")," is an object of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Fiber"),", which we have just explored. The second parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"container")," is of the type ",(0,a.kt)("inlineCode",{parentName:"p"},"HTMLElement"),". Inside the container the newly created element will be rendered, meaning it's a reference to some HTML element that must already exist inside the DOM when we call the ",(0,a.kt)("inlineCode",{parentName:"p"},"render")," function. In the example of ",(0,a.kt)("inlineCode",{parentName:"p"},"index.js")," given at the beginning of this level, you can see that we can get such a reference for example by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"document.getElementById('app')"),"."),(0,a.kt)("p",null,"In the first line of the ",(0,a.kt)("inlineCode",{parentName:"p"},"render")," function, all elements that already exist inside ",(0,a.kt)("inlineCode",{parentName:"p"},"container")," are first removed. With that, we make sure that only elements which are rendered by SuiWeb exist inside the container, which makes the result more predictable."),(0,a.kt)("h3",{id:"the-renderfiber-function"},"The ",(0,a.kt)("inlineCode",{parentName:"h3"},"renderFiber")," Function"),(0,a.kt)("p",null,"After this, the function ",(0,a.kt)("inlineCode",{parentName:"p"},"renderFiber")," is called. This function is not publicly exported, meaning that unlike ",(0,a.kt)("inlineCode",{parentName:"p"},"render"),", it does not have the ",(0,a.kt)("inlineCode",{parentName:"p"},"export")," keyword before the function definition, and thus we can't call it directly."),(0,a.kt)("p",null,"For now, let's look at a simpler version of the ",(0,a.kt)("inlineCode",{parentName:"p"},"renderFiber")," function, which contains just the elements we need in this level. Of course, you can also look at the ",(0,a.kt)("em",{parentName:"p"},"real")," function definition in the source code of SuiWeb, but this will contain a lot more code which we will not ",(0,a.kt)("em",{parentName:"p"},"yet")," explain in this level, so it might be a bit confusing for the moment."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function renderFiber(fiber: Fiber, container: HTMLElement, previousVersion?: Fiber, nextSibling?: Fiber) {\n    if (!isStaticFiber(fiber)) throw new Error('Fiber did not contain all StaticFiber properties after unwrapping.')\n\n    replaceFiberInDom(fiber, container, previousVersion, nextSibling)\n\n    expandChildFibers(fiber, previousVersion)\n}\n")),(0,a.kt)("p",null,"You can see that the function contains four parameters in total, of which the last two are optional. In our first call to ",(0,a.kt)("inlineCode",{parentName:"p"},"renderFiber")," inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"render")," function, we omit those optional parameters, so you can assume that the parameters ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"nextSibling")," are ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined")," in the snippet above."),(0,a.kt)("p",null,"In the first line, it is checked whether the parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber")," satisfies the type ",(0,a.kt)("inlineCode",{parentName:"p"},"StaticFiber"),", by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"isStaticFiber(fiber)"),". If this is not the case, an error will be thrown. For the moment, we will not go too deep into why this check is there, as it will only become really relevant when we also deal with Functional Fibers. "),(0,a.kt)("p",null,"Next, the execution will continue with a call to ",(0,a.kt)("inlineCode",{parentName:"p"},"replaceFiberInDom"),"."),(0,a.kt)("h3",{id:"creating-dom-nodes"},"Creating DOM Nodes"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function replaceFiberInDom(fiber: StaticFiber, container: HTMLElement, previousVersion?: Fiber, nextSibling?: Fiber) {\n    // Remove DOM node of the previous version from the DOM\n    previousVersion?.domNode?.remove()\n\n    // Create DOM node for new fiber\n    const newDomNode = createDomNode(fiber)\n    fiber.domNode = newDomNode\n    container.insertBefore(newDomNode, nextSibling?.domNode ?? null)\n}\n")),(0,a.kt)("p",null,"As we have not passed anything for ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion"),", the first line does not do anything. It will become important later, when we deal with re-rendering. Next, a new DOM node is created, which is either an ",(0,a.kt)("inlineCode",{parentName:"p"},"HTMLElement")," or a ",(0,a.kt)("inlineCode",{parentName:"p"},"Text")," element. Those are built-in types of JavaScript which are used for elements inside an HTML page. "),(0,a.kt)("p",null,"On the last line, the created element is inserted into the DOM. As the ",(0,a.kt)("inlineCode",{parentName:"p"},"nextSibling")," is currently ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined"),", it will just be added as the last child inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"container"),". Later, when rendering the children of this fiber, we will use the ",(0,a.kt)("inlineCode",{parentName:"p"},"nextSibling")," to insert the element at the correct position in the ",(0,a.kt)("inlineCode",{parentName:"p"},"container")," (before its next sibling)."),(0,a.kt)("p",null,"If we look at the ",(0,a.kt)("inlineCode",{parentName:"p"},"createDomNode")," function, we can see that here we make use of our special ",(0,a.kt)("inlineCode",{parentName:"p"},"Fiber")," with type ",(0,a.kt)("inlineCode",{parentName:"p"},"TEXT_NODE"),". If we detect a ",(0,a.kt)("inlineCode",{parentName:"p"},"Fiber")," to be of this type, we will use ",(0,a.kt)("inlineCode",{parentName:"p"},"document.createTextNode('')")," to create a new object of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Text"),", which can then be used for example as the text value of a ",(0,a.kt)("inlineCode",{parentName:"p"},"p")," HTML tag. Note that we create a ",(0,a.kt)("inlineCode",{parentName:"p"},"Text")," node with an empty value for now, as we'll update the text value in the next step anyway."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export function createDomNode(fiber: StaticFiber): Text | HTMLElement {\n    // The elements are created \"empty\", without any props. These will be assigned in updateDomNode (e.g. nodeValue of a Text).\n    const domNode = fiber.type === 'TEXT_NODE' ? document.createTextNode('') : document.createElement(fiber.type)\n    // Set to props of the fiber.\n    updateDomNode(domNode, undefined, fiber.props)\n\n    return domNode\n}\n")),(0,a.kt)("p",null,"In case of ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," being of any other value, we use ",(0,a.kt)("inlineCode",{parentName:"p"},"document.createElement(fiber.type)")," to create a new HTML element with the type that is present in the ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber"),"'s ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," property."),(0,a.kt)("h3",{id:"updating-dom-nodes"},"Updating DOM Nodes"),(0,a.kt)("p",null,"After we created our ",(0,a.kt)("inlineCode",{parentName:"p"},"domNode"),", it's time to make sure that this node contains all it's required properties. For that, we call the function ",(0,a.kt)("inlineCode",{parentName:"p"},"updateDomNode"),", and pass it our ",(0,a.kt)("inlineCode",{parentName:"p"},"domNode")," and the ",(0,a.kt)("inlineCode",{parentName:"p"},"props")," of our ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber"),". Note that ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined")," is passed for the second parameter (",(0,a.kt)("inlineCode",{parentName:"p"},"previousProps"),") as there are no previous props in case of creating a ",(0,a.kt)("em",{parentName:"p"},"new")," DOM node. Previous props will become relevant later, when we ",(0,a.kt)("em",{parentName:"p"},"update")," an existing DOM node."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export function updateDomNode(domNode: HTMLElement | Text, previousProps: Props = {}, currentProps: Props = {}) {\n    if (isText(domNode)) {\n        domNode.nodeValue = currentProps.nodeValue ?? ''\n        return\n    }\n\n    const isEvent = (key: string) => key.startsWith('on')\n\n    // Remove old event-listeners\n    Object.keys(previousProps)\n        .filter(isEvent)\n        .forEach(name => {\n            const eventType = name.toLowerCase().substring(2)\n            const event = previousProps[name] as EventListenerOrEventListenerObject\n            domNode.removeEventListener(eventType, event)\n        })\n\n    // Add new event-listeners\n    Object.keys(currentProps)\n        .filter(isEvent)\n        .forEach(name => {\n            const eventType = name.toLowerCase().substring(2)\n            const event = currentProps[name] as EventListenerOrEventListenerObject\n            domNode?.addEventListener(eventType, event)\n        })\n\n    // Remove old properties\n    Object.keys(previousProps)\n        .filter(isNormalProp)\n        .forEach(name => {\n            domNode.removeAttribute(name)\n        })\n\n    // Set new properties\n    Object.keys(currentProps)\n        .filter(isNormalProp)\n        .forEach(name => {\n            const value = currentProps[name]?.toString()\n            if (value) domNode.setAttribute(name, value)\n        })\n\n    // Upate special style prop\n    updateStyleAttribute(domNode, currentProps.style)\n}\n")),(0,a.kt)("p",null,"The implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"updateDomNode")," is actually quite straight forward and should be self-explanatory by looking at the code and the corresponding comments: We just loop through all ",(0,a.kt)("inlineCode",{parentName:"p"},"previousProps")," and ",(0,a.kt)("em",{parentName:"p"},"remove")," them from the node, and then through all ",(0,a.kt)("inlineCode",{parentName:"p"},"currentProps"),", which we ",(0,a.kt)("em",{parentName:"p"},"add")," to the node. This allows updating existing elements in the DOM, which we do not need now, but will be relevant later. For ",(0,a.kt)("inlineCode",{parentName:"p"},"Text")," nodes, we can also see that their value is updated, by setting the ",(0,a.kt)("inlineCode",{parentName:"p"},"nodeValue")," of the ",(0,a.kt)("inlineCode",{parentName:"p"},"domNode")," to the value which is present in ",(0,a.kt)("inlineCode",{parentName:"p"},"currentProps"),"."),(0,a.kt)("p",null,"Lastly, style attributes are updated using the ",(0,a.kt)("inlineCode",{parentName:"p"},"updateStyleAttributes")," function, of which the implementation is below."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function updateStyleAttribute(htmlElement: HTMLElement, styles: StyleProp = {}) {\n    const updateObjStyles = (styleObj: Partial<CSSStyleDeclaration>) =>\n        Object.entries(styleObj).forEach(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            ([key, value]) => ((htmlElement.style as any)[key] = value?.toString() ?? null)\n        )\n\n    // Reset the current style of the element.\n    htmlElement.removeAttribute('style')\n\n    // Set the new styles of the element.\n    if (typeof styles === 'string') {\n        htmlElement.style.cssText = styles\n    } else if (Array.isArray(styles)) {\n        styles.forEach(objStyles => updateObjStyles(objStyles))\n    } else if (typeof styles === 'object') {\n        updateObjStyles(styles)\n    }\n}\n")),(0,a.kt)("p",null,"It's actually not that important that you understand every single detail of ",(0,a.kt)("inlineCode",{parentName:"p"},"updateDomNode")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"updateStyleAttributes"),", you should just know that the functions are used to ",(0,a.kt)("em",{parentName:"p"},"apply")," changes defined inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"props")," of a ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber")," to their corresponding node in the DOM."),(0,a.kt)("h3",{id:"the-expandchildfibers-function"},"The ",(0,a.kt)("inlineCode",{parentName:"h3"},"expandChildFibers")," Function"),(0,a.kt)("p",null,"Coming back to the last line of ",(0,a.kt)("inlineCode",{parentName:"p"},"renderFiber"),", we see that after the ",(0,a.kt)("em",{parentName:"p"},"current")," ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber")," has been placed in the DOM, we call ",(0,a.kt)("inlineCode",{parentName:"p"},"expandChildFibers"),". Below you can see a simplified version of the implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"expandChildFibers"),". You can ignore the parameter ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion"),", as it is not used for now."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function expandChildFibers(fiber: StaticFiber, previousVersion?: Fiber) {\n    const currentChildren = fiber.children\n\n    // If the domNode of the container is not a HTMLElement, no children can be added to it.\n    const container = fiber.domNode\n    if (!container || !isHTMLElement(container)) return\n\n    // Go through all currentChildren and render them to the DOM.\n    // The nextChildSibling is used to enforce the correct order in the DOM.\n    // The order is reversed, to determine the nextChildSibling easily (to use insertBefore API).\n    let nextChildSibling: Fiber | undefined\n    const reversedChildren = Array.from(currentChildren.entries()).reverse()\n    reversedChildren.forEach(([key, currentChild]) => {\n        renderFiber(currentChild, container, undefined, nextChildSibling)\n        nextChildSibling = currentChild\n    })\n}\n")),(0,a.kt)("p",null,"We can see that the ",(0,a.kt)("inlineCode",{parentName:"p"},"domNode")," of the ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber")," we passed to the function is taken as our container, into which we're now going to render all its children."),(0,a.kt)("p",null,"Next, we create an array of all children of our ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber"),", and reverse it. In that way it is easier for us to determine the ",(0,a.kt)("em",{parentName:"p"},"next")," sibling of the child. The explanation why we need the ",(0,a.kt)("em",{parentName:"p"},"next")," sibling (and not the ",(0,a.kt)("em",{parentName:"p"},"previous"),") is related to the JavaScript DOM API, as this contains only the function ",(0,a.kt)("inlineCode",{parentName:"p"},"Node.insertBefore(newNode, referenceNode)")," (and nothing like ",(0,a.kt)("inlineCode",{parentName:"p"},"Node.insertAfter(newNode, referenceNode)"),"). We already used this function inside ",(0,a.kt)("inlineCode",{parentName:"p"},"replaceFiberInDom"),"."),(0,a.kt)("p",null,"Then, we loop through our ",(0,a.kt)("inlineCode",{parentName:"p"},"reversedChildren")," array and call ",(0,a.kt)("inlineCode",{parentName:"p"},"renderFiber"),", meaning all children of a ",(0,a.kt)("inlineCode",{parentName:"p"},"fiber")," will be rendered recursively to the DOM."),(0,a.kt)("h2",{id:"review"},"Review"),(0,a.kt)("p",null,"Going back to our demo from the beginning of this level, you should now understand that we used the ",(0,a.kt)("inlineCode",{parentName:"p"},"createElement")," function to create a ",(0,a.kt)("inlineCode",{parentName:"p"},"StaticFiber")," of ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," ",(0,a.kt)("inlineCode",{parentName:"p"},"h1"),", passed some props to define the styles of our ",(0,a.kt)("inlineCode",{parentName:"p"},"h1")," element and added a single child with a ",(0,a.kt)("em",{parentName:"p"},"primitive")," value, which was added as the text node of our ",(0,a.kt)("inlineCode",{parentName:"p"},"h1")," element."),(0,a.kt)("p",null,"This ",(0,a.kt)("inlineCode",{parentName:"p"},"Fiber")," was then transformed to an HTML element and rendered inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"div")," with the ID ",(0,a.kt)("inlineCode",{parentName:"p"},"app"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"import { createElement } from '../../lib/js/fiber.js'\nimport { render } from '../../lib/js/render.js'\n\nconst fiber = createElement('h1', { style: { color: 'Salmon' } }, 'Hello World')\n\nrender(\n    fiber,\n    document.getElementById('app')\n)\n")),(0,a.kt)("p",null,"With that, you have almost finished the first chapter of this tutorial and should now understand what a ",(0,a.kt)("inlineCode",{parentName:"p"},"Fiber")," (or more precisely, ",(0,a.kt)("inlineCode",{parentName:"p"},"StaticFiber"),") is, and how its properties are used to render it to the DOM, using the ",(0,a.kt)("inlineCode",{parentName:"p"},"render")," function and all the internal functions which are needed to make this work."),(0,a.kt)("h3",{id:"more-advanced-example"},"More Advanced Example"),(0,a.kt)("p",null,"In the example we have looked at so far, we have just rendered a single HTML element to the DOM. However, we could also use this approach to render a much more complex structure, with nested elements, advanced styling, etc.:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"import { createElement } from '../../lib/js/fiber.js'\nimport { render } from '../../lib/js/render.js'\n\nconst fiber = createElement(\n    'div',\n    { style: {\n        height: '100vh',\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n    } },\n    createElement(\n        'main',\n        { style: {\n            textAlign: 'center',\n            padding: '2rem'\n        } },\n        createElement(\n            'h1', \n            { style: { color: 'Salmon' } }, \n            'Hello World'\n        ),\n        createElement(\n            'h2', \n            { style: { color: 'DarkCyan' } }, \n            'This is a subtitle'\n        ),\n        createElement(\n            'p', \n            null, \n            'And here follows a paragraph which contains some normal text.'\n        )\n    )\n)\n\nrender(\n    fiber,\n    document.getElementById('app')\n)\n")),(0,a.kt)("p",null,"You might agree that this approach seems to contain quite a lot of boilerplate. Because of this, it's a good idea to look into the ",(0,a.kt)("a",{parentName:"p",href:"/docs/tutorial/2-parsing-sjdon/"},"second level"),", where we'll explore a more elegant way to define our fibers."))}c.isMDXComponent=!0}}]);