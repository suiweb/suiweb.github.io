"use strict";(self.webpackChunksuiweb_website=self.webpackChunksuiweb_website||[]).push([[685],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=i.createContext({}),s=function(e){var t=i.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return i.createElement(p.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=s(n),m=a,u=c["".concat(p,".").concat(m)]||c[m]||h[m]||r;return n?i.createElement(u,o(o({ref:t},d),{},{components:n})):i.createElement(u,o({ref:t},d))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[c]="string"==typeof e?e:a,o[1]=l;for(var s=2;s<r;s++)o[s]=n[s];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2896:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var i=n(7462),a=(n(7294),n(3905));const r={},o="Level 7: Rendering a Dynamic Amount of Elements",l={unversionedId:"tutorial/7-dynamic-rendering/README",id:"tutorial/7-dynamic-rendering/README",title:"Level 7: Rendering a Dynamic Amount of Elements",description:"Introduction",source:"@site/docs/tutorial/7-dynamic-rendering/README.md",sourceDirName:"tutorial/7-dynamic-rendering",slug:"/tutorial/7-dynamic-rendering/",permalink:"/docs/tutorial/7-dynamic-rendering/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"apiSidebar",previous:{title:"Level 6: Conditionally Showing Elements",permalink:"/docs/tutorial/6-conditional-rendering/"},next:{title:"Level 8: Wrapping Everything Up",permalink:"/docs/tutorial/8-wrap-up/"}},p={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Goal",id:"goal",level:2},{value:"<code>index.js</code>",id:"indexjs",level:3},{value:"Implementation in <code>mapChildren</code>",id:"implementation-in-mapchildren",level:2},{value:"Review",id:"review",level:2}],d={toc:s};function c(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"level-7-rendering-a-dynamic-amount-of-elements"},"Level 7: Rendering a Dynamic Amount of Elements"),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"In the previous level we have seen a possibility to only show a component if a certain condition is met. But what if we need some more flexibility on which items are displayed, by using a function such as ",(0,a.kt)("inlineCode",{parentName:"p"},"map")," to render each item of a dataset as a component. And what if the items or the order of the items in the dataset changes? It becomes clear that the current way to identify items just with the order in which they have been added will no longer work after a change in the dataset. That's why we need a more advanced way to identify our items, even if the underlying dataset has changed. For that, we look at the possibility to define a ",(0,a.kt)("inlineCode",{parentName:"p"},"key")," for elements, which will be necessary to solve problems like the one described before."),(0,a.kt)("h2",{id:"goal"},"Goal"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://suiweb.github.io/demos/tutorial/07-dynamic-rendering/index.html"},"Demo")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/suiweb/suiweb/tree/main/demos/tutorial/07-dynamic-rendering"},"Source Code"))),(0,a.kt)("p",null,"Let's look at the demo we have set up for this level. We try to recreate a situation similar to the one described in the introduction."),(0,a.kt)("p",null,"We have two arrays of objects, ",(0,a.kt)("inlineCode",{parentName:"p"},"primary")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"alternate"),", which represent our changing dataset. The objects in the dataset contain two properties ",(0,a.kt)("inlineCode",{parentName:"p"},"key")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"name"),". Additionally, we have a button, that changes the state of ",(0,a.kt)("inlineCode",{parentName:"p"},"toggle")," on every click. Based on the value of ",(0,a.kt)("inlineCode",{parentName:"p"},"toggle"),", the value of ",(0,a.kt)("inlineCode",{parentName:"p"},"mapped")," is assigned: If toggle is ",(0,a.kt)("inlineCode",{parentName:"p"},"true"),", we create a ",(0,a.kt)("inlineCode",{parentName:"p"},"TextField")," component for every item in ",(0,a.kt)("inlineCode",{parentName:"p"},"primary"),", else we create a ",(0,a.kt)("inlineCode",{parentName:"p"},"TextField")," for every item in ",(0,a.kt)("inlineCode",{parentName:"p"},"alternate"),". In the return statement of the function, we spread all items of ",(0,a.kt)("inlineCode",{parentName:"p"},"mapped"),", so they will be added as children to the ",(0,a.kt)("inlineCode",{parentName:"p"},"div")," wrapping the items."),(0,a.kt)("p",null,"You can see the source code of this demo below."),(0,a.kt)("h3",{id:"indexjs"},(0,a.kt)("inlineCode",{parentName:"h3"},"index.js")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"import { createElement } from '../../lib/js/fiber.js'\nimport { useState } from '../../lib/js/hooks.js'\nimport { render } from '../../lib/js/render.js'\nimport { parseSjdon } from '../../lib/js/sjdon.js'\n\n\nconst App = () => {\n    const [toggle, setToggle] = useState(true)\n\n    const primary = [\n        { key: 'first', name: 'First (primary)' },\n        { key: 'second', name: 'Second (primary)' },\n        { key: 'third', name: 'Third (primary)' },\n        { key: 'fourth', name: 'Fourth (primary)' },\n        { key: 'fifth', name: 'Fifth (primary)' },\n        { key: 'sixth', name: 'Sixth (primary)' },\n    ]\n    const alternate = [\n        { key: 'third', name: 'Third (alternate)' },\n        { key: 'fourth', name: 'Fourth (alternate)' },\n        { key: 'second', name: 'Second (alternate)' },\n    ]\n\n    const mapped = toggle\n        ? primary.map((item, idx) => [TextField, { name: item.name, key: item.key }])\n        : alternate.map((item, idx) => [TextField, { name: item.name, key: item.key }])\n\n    return [\n        'div',\n        ['button', { onclick: () => setToggle(!toggle) }, `Toggled:${toggle}`],\n        ...mapped,\n    ]\n}\n\nconst TextField = props => {\n    const [text, setText] = useState(props?.initialValue ?? '')\n    return [\n        'div',\n        ['label', `Key: ${props?.key}, Name: ${props?.name} `,\n            [\n                'input',\n                {\n                    value: text,\n                    oninput: event => setText(event.target.value),\n                },\n            ],\n        ],\n        ['p', 'Value: ', ['strong', text]],\n    ]\n}\n\nrender(\n    parseSjdon([App], createElement), \n    document.getElementById('app')\n)\n")),(0,a.kt)("p",null,"If we render this app and enter some values into the text fields and then click the toggle button, we realize that some text fields will disappear, some change their position and others are added. You should understand what changes happen when you compare ",(0,a.kt)("inlineCode",{parentName:"p"},"primary")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"alternate")," in the example above. If we think back to the ",(0,a.kt)("a",{parentName:"p",href:"/docs/tutorial/6-conditional-rendering/"},"previous level"),", you might realize that something like this would not have been possible using the conditional rendering we've looked at so far, as SuiWeb now seems to recognize that something is the same item, even though the order has changed. The reason why this is possible now, is that we assigned an explicit ",(0,a.kt)("inlineCode",{parentName:"p"},"key")," to our items. You can see inside the assignment of ",(0,a.kt)("inlineCode",{parentName:"p"},"mapped"),", where we create a ",(0,a.kt)("inlineCode",{parentName:"p"},"TextField")," for every item, that we set the property ",(0,a.kt)("inlineCode",{parentName:"p"},"key")," of the ",(0,a.kt)("inlineCode",{parentName:"p"},"TextField")," component to the value of ",(0,a.kt)("inlineCode",{parentName:"p"},"item.key"),"."),(0,a.kt)("h2",{id:"implementation-in-mapchildren"},"Implementation in ",(0,a.kt)("inlineCode",{parentName:"h2"},"mapChildren")),(0,a.kt)("p",null,"Below, we can see an excerpt of the ",(0,a.kt)("inlineCode",{parentName:"p"},"mapChildren")," function, at which we already looked in previous levels. The highlighted lines show that we insert a child fiber with the key ",(0,a.kt)("inlineCode",{parentName:"p"},"e-${childProps?.key}")," into the ",(0,a.kt)("inlineCode",{parentName:"p"},"childrenMap")," on its parent fiber, in case ",(0,a.kt)("inlineCode",{parentName:"p"},"childProps")," contains the property ",(0,a.kt)("inlineCode",{parentName:"p"},"key"),". This is the case in the example of this level, as we passed a property ",(0,a.kt)("inlineCode",{parentName:"p"},"key")," in the props of the component. Otherwise, the default key ",(0,a.kt)("inlineCode",{parentName:"p"},"d-${defaultKey++}")," would be used, what we have already seen in the ",(0,a.kt)("a",{parentName:"p",href:"/docs/tutorial/6-conditional-rendering/"},"previous level"),". "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const childrenMap: Map<string, Fiber> = new Map()\nlet defaultKey = 0\nchildren.forEach(child => {\n    const childProps = isFunctionalFiber(child) ? child.functionProps : child.props\n    // Keys are prefixed e-(xplicit) or d-(efault), so a custom key can never\n    // accidentally match a generated key.\n    // highlight-start\n    const key = childProps?.key ? `e-${childProps?.key}` : `d-${defaultKey++}`\n    childrenMap.set(key, child)\n    // highlight-end\n})\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note that by prefixing our keys with either ",(0,a.kt)("inlineCode",{parentName:"p"},"e")," (for ",(0,a.kt)("strong",{parentName:"p"},"e"),"xplicit) or ",(0,a.kt)("inlineCode",{parentName:"p"},"d")," (for ",(0,a.kt)("strong",{parentName:"p"},"d"),"efault), we make sure that we never accidentally assign an explicit key that is identical to a default key.")),(0,a.kt)("p",null,"As we now have a unique key to differentiate all the sibling elements (in the example the ",(0,a.kt)("inlineCode",{parentName:"p"},"TextField"),"s), the function ",(0,a.kt)("inlineCode",{parentName:"p"},"expandChildFibers"),", which we looked at in the previous levels, does not have any problem finding the correct child elements in the ",(0,a.kt)("inlineCode",{parentName:"p"},"previousVersion"),", even if the order of the children has completely changed. By setting the ",(0,a.kt)("inlineCode",{parentName:"p"},"key")," manually, the order is now completely irrelevant (in contrast to default keys, where the keys are created incrementally in the order of the children)."),(0,a.kt)("h2",{id:"review"},"Review"),(0,a.kt)("p",null,"This has already been it for this level. As you have seen, assigning explicit keys internally works almost the same as generating a default key. The only difference is that if we want to use an explicit key, we need to pass it via the props of the component."),(0,a.kt)("p",null,"With this level, you should also understand why it's required in some cases to assign an explicit key, while we can omit it in other cases, because we can do some internal ",(0,a.kt)("em",{parentName:"p"},"tricks"),", such as using placeholder fibers."),(0,a.kt)("p",null,"By the way: In React, about the same rules apply on when a key can be generated automatically, and when one needs to be set explicitly."),(0,a.kt)("p",null,"Now, we have completed basically all the functionality of SuiWeb. In the ",(0,a.kt)("a",{parentName:"p",href:"/docs/tutorial/8-wrap-up/"},"next level"),", we are going to wrap everything up, by looking at the full chain of function calls that occur if we render an app with SuiWeb."))}c.isMDXComponent=!0}}]);